<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.  谈谈你对vue的理解​    Vue是一套用于构建用户界面的渐进式JavaScript框架，目前Vue的版本最新为去年发布的3.0.0，但由于市场普及度不够，目前还是版本2.0.0使用最为普遍。 ​    从整体概念出发来看，Vue作为一套渐进式框架，采用按需分配的模式，就是用多少便引入多少，由开发者自定决定，这提高了项目的运行效率。而且Vue的核心库只关心视图层，比较容易上手，还便于和第">
<meta property="og:type" content="article">
<meta property="og:title" content="vue面试题">
<meta property="og:url" content="http://example.com/2017/05/26/%E5%88%9D%E8%AF%86vue/index.html">
<meta property="og:site_name" content="亚丽的博客">
<meta property="og:description" content="1.  谈谈你对vue的理解​    Vue是一套用于构建用户界面的渐进式JavaScript框架，目前Vue的版本最新为去年发布的3.0.0，但由于市场普及度不够，目前还是版本2.0.0使用最为普遍。 ​    从整体概念出发来看，Vue作为一套渐进式框架，采用按需分配的模式，就是用多少便引入多少，由开发者自定决定，这提高了项目的运行效率。而且Vue的核心库只关心视图层，比较容易上手，还便于和第">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-05-26T04:12:57.000Z">
<meta property="article:modified_time" content="2022-04-06T07:31:41.542Z">
<meta property="article:author" content="亚丽">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2017/05/26/%E5%88%9D%E8%AF%86vue/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>vue面试题 | 亚丽的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">亚丽的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2017/05/26/%E5%88%9D%E8%AF%86vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="亚丽">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="亚丽的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          vue面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-26 12:12:57" itemprop="dateCreated datePublished" datetime="2017-05-26T12:12:57+08:00">2017-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-06 15:31:41" itemprop="dateModified" datetime="2022-04-06T15:31:41+08:00">2022-04-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h5 id="1-谈谈你对vue的理解"><a href="#1-谈谈你对vue的理解" class="headerlink" title="1.  谈谈你对vue的理解"></a>1.  谈谈你对vue的理解</h5><p>​    Vue是一套用于构建用户界面的渐进式JavaScript框架，目前Vue的版本最新为去年发布的3.0.0，但由于市场普及度不够，目前还是版本2.0.0使用最为普遍。</p>
<p>​    从整体概念出发来看，Vue作为一套渐进式框架，采用按需分配的模式，就是用多少便引入多少，由开发者自定决定，这提高了项目的运行效率。而且Vue的核心库只关心视图层，比较容易上手，还便于和第三方库或者既有的项目整合。除此之外还有用体积小运行效率高，适合于移动和PC端的开发等优点。然后还借鉴了angular的模板和数据绑定技术以及react的组件化和虚拟DOM技术。</p>
<p>​    从功能方面来看，Vue最核心的功能有两个，一个是响应式数据绑定系统，一个是组件系统。响应式数据系统实现了数据的双向绑定，实现原理是采用数据劫持和订阅-观察模式的结合；组件系统的存在实现了对可重用代码的封装，且扩展了HTML标签的功能。组件之间是相互独立的，无法直接通信，但可以采用一定的办法进行通信。且组件之间可以嵌套，组件也能够被多次复用。</p>
<p>​    Vue还有一系列的扩展插件，比如vue-cli、vue-axios、vue-router、vuex状态管理、vue-lazyload图片懒加载，以及基于Vue的移动端UI组件mint-ui和基于PC端的UI组件库。</p>
<h5 id="2-说说你对-SPA-单页面的理解，它的优缺点分别是什么"><a href="#2-说说你对-SPA-单页面的理解，它的优缺点分别是什么" class="headerlink" title="2. 说说你对 SPA 单页面的理解，它的优缺点分别是什么"></a>2. 说说你对 SPA 单页面的理解，它的优缺点分别是什么</h5><p>​    SPA单页面就是指整个应用只有一个web页面，点击页面中的链接不会刷新页面，只会做页面的局部更新，数据都来自于异步请求，核心技术为前端路由，即Vue-router</p>
<p>​    使用SPA的优点：首先对用户来说，由于单页面应用内容的改变不需要刷新页面没有页面之间的切换，所以页面显示流畅，不会出现白屏的卡顿现象，因此会有良好的用户体验。其次对开发人员来说，由于使用了前后端工作分离模式，后端不再负责模板渲染工作、输出页面工作，实现了后端API通用化，大大减轻了开发人员的工作量。最后对服务器来说，由于单页面应用相对服务器压力小，服务器只用输出数据就可以，不用管展示逻辑和页面合成，所以大大减轻了服务器的压力</p>
<p>​    缺点：首先如果不对路由进行懒加载处理的话，在加载首页的时候，就会将所有组件进行全部加载，导致首屏加载速度过慢的问题。其次SPA不适用于开发大型项目，因为大型项目中会设计大量的DOM操作和复杂的动画效果。最后不利于seo，seo是一个服务器向另一个服务器发起请求，解析请求内容；如果主要解析的内容在还没有加载出的页面中，就会导致内容不利于被搜索引擎搜索到。</p>
<h5 id="3-谈谈你对MVC、MVP、MVVM的理解"><a href="#3-谈谈你对MVC、MVP、MVVM的理解" class="headerlink" title="3.  谈谈你对MVC、MVP、MVVM的理解"></a>3.  谈谈你对MVC、MVP、MVVM的理解</h5><p>​    三种都是开发过程所使用的架构模式，</p>
<p>​    其中MVC是最常见的软件架构之一，该架构分为View视图层、Controller控制层、Model模型层三个部分，工作原理为视图层将用户指令传送到控制层，控制层完成业务逻辑后要求模型层改变状态，模型层将新的数据发送到视图层，使得用户得到反馈。该模式下的所有通信都是单向的，且模型层不依赖于视图层，但是视图层是依赖于模型层的，哦从而导致视图层无法组件化，无法复用。</p>
<p>​    MVP是从MVC模式演变而来的，将Controller改名为Presenter，同时改变了通信方向。与MVC不同的是视图层不直接与模型层进行交互，而是通过控制层来完成交互的，这样可以修改视图而不影响模型，达到解耦的目的，实现了模型层和视图层的真正完全的分离，但模型层到视图层的数据传递过程麻烦，不易维护。</p>
<p>​    MVVM在MVP的模式上继续进行了演变，将Presenter改名为ViewModel，与MVP模式基本一致。唯一的区别是，MVVM采用双向绑定：即View视图层的变动会自动反映在ViewModel上。该模式主要解决了MVP中大量DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验的问题。</p>
<h5 id="4-双向绑定原理分析"><a href="#4-双向绑定原理分析" class="headerlink" title="4. 双向绑定原理分析"></a>4. 双向绑定原理分析</h5><p>​    双向绑定原理是采用数据劫持和订阅-观察者模式的结合而实现的，流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先观察者将遍历Vue对象所有属性，并使用Object.defineProperty把这些属性全部转为getter/setter，从而实现数据劫持；</span><br><span class="line"></span><br><span class="line">​	其次观察者为每个属性分配一个订阅者集合的管理数组dep，然后在编译的时候在该属性的数组dep中添加订阅者Watcher，v-model会添加一个订阅者，&#123;&#123;&#125;&#125;也会，v-bind也会，只要用到该属性的指令理论上都会；</span><br><span class="line"></span><br><span class="line">​	最后为input添加监听事件，修改值时则会触发该属性的set方法，在set方法内通知订阅者数组dep，订阅者数组循环通知各订阅者更新视图；</span><br><span class="line"></span><br><span class="line">​	vue是通过render函数来生成虚拟dom，再映射到页面上</span><br></pre></td></tr></table></figure>

<h5 id="5-虚拟dom的实现原理及优缺点"><a href="#5-虚拟dom的实现原理及优缺点" class="headerlink" title="5.  虚拟dom的实现原理及优缺点"></a>5.  虚拟dom的实现原理及优缺点</h5><p>​    实现原理：<br>​    虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象；状态变更时，记录新树和旧树的差异；最后把差异更新到真正的dom中。</p>
<p>​    优点：<br>​    保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限<br>​    无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率<br>​    跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</p>
<p>​    缺点：<br>​    无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优化</p>
<h5 id="6-常用的vue指令有哪些，各有什么作用"><a href="#6-常用的vue指令有哪些，各有什么作用" class="headerlink" title="6. 常用的vue指令有哪些，各有什么作用"></a>6. 常用的vue指令有哪些，各有什么作用</h5><p>​    在事件绑定上有v-on可简写为@用来绑定事件监听器，实现交互效果，如果事件处理程序比较复杂，也可以指定一个方法 用法为@事件名=‘方法’或者@事件名=‘方法($event)’，方法后不跟括号时，默认第一个参数就是事件对象 ，跟括号时，传递事件对象必须用括号中的参数。</p>
<p>​    在属性绑定上有v-bind，用于绑定html元素属性，可简写为：，绑定class选择器与style行内样式时，都有字符串、对象、数组三种形式。</p>
<p>​    在条件渲染上有v-if v-show，v-if可以根据条件在DOM中渲染或销毁元素或组件，v-show通过改变元素的display属性进行显示和隐藏。v-if适合于条件不经常改变的的场景，因为他的切换开销相对较大，而v-shoe适合于频繁切换条件的场景。</p>
<p>​    在列表渲染中有v-for，用于循环遍历，需要结合in来使用，类似于原生js中for in的用法。</p>
<p>​    在内容绑定上有v-text v-html v-pre v-once，其中v-text用于实现文本插值，与插入表达式同时存在时，该指令生效而表达式不生效，但不建议使用v-text。v-html用于解决插入表达式中含有标签的问题。v-pre和v-once是一个不需要值的指令，前者作用是跳过这个元素和它的子元素的编译过程，是内容原样显示、后者的作用是定义的䛾或组件只能被渲染一次，首次渲染后，不会再随数据的变化而重新渲染。</p>
<p>​    表单元素绑定中的v-model用于实现双向绑定</p>
<p>​    还有自定义指令，可以使用directive注册全局自定义指令，也可以使用directives注册局部自定义指令。</p>
<h5 id="7-常用的事件修饰符有哪些？"><a href="#7-常用的事件修饰符有哪些？" class="headerlink" title="7. 常用的事件修饰符有哪些？"></a>7. 常用的事件修饰符有哪些？</h5><p>​    @click.pevent=’方法’      阻止默认行为</p>
<p>​    @click.stop=’方法’     阻止冒泡</p>
<p>​    @submit.prevent         阻止表单提交，后面不需要跟方法</p>
<p>​    @click.once=”方法”        只触发一次</p>
<p>​    @keyup.enter/tab/delete/esc/space/up/down/left/right</p>
<p>​    @keyup.keyCode.13=’方法’</p>
<p>​    @click.capture=’方法’    采用事件捕获方式</p>
<h5 id="8-v-if和v-show的区别"><a href="#8-v-if和v-show的区别" class="headerlink" title="8. v-if和v-show的区别"></a>8. v-if和v-show的区别</h5><p>​    v-if是通过创建和销毁DOM元素进行内容操作的，而v-show是通过改变元素display属性进行显示和隐藏来操作内容的。</p>
<h5 id="9-v-for中的key属性的作用"><a href="#9-v-for中的key属性的作用" class="headerlink" title="9. v-for中的key属性的作用"></a>9. v-for中的key属性的作用</h5><p>​    使用v-for更新一渲染的元素列表时，默认用就地服用的策略，列表数据修改的时候，会根据key值去判断某个值是否被修改，如果修改则重新渲染这一项，否则复用之前的元素。</p>
<h5 id="10-v-for和v-if-谁优先级高，为什么不建议一起用"><a href="#10-v-for和v-if-谁优先级高，为什么不建议一起用" class="headerlink" title="10. v-for和v-if 谁优先级高，为什么不建议一起用"></a>10. v-for和v-if 谁优先级高，为什么不建议一起用</h5><p>​    v-for优先级高</p>
<p>​    同时使用时，每次渲染都会先循环然后再进行条件判断，带来性能上的浪费</p>
<h5 id="11-如何动态绑定样式Class-与-Style"><a href="#11-如何动态绑定样式Class-与-Style" class="headerlink" title="11. 如何动态绑定样式Class 与 Style"></a>11. 如何动态绑定样式Class 与 Style</h5><p>​    首先使用v-bind指令，然后可以给其传一个对象或者数组，在对象中定义多个字段来动态的切换多个class或行内样式，style可以直接绑定一个样式对象，</p>
<p>​    </p>
<h5 id="12-computed-和-watch-的区别和运用的场景"><a href="#12-computed-和-watch-的区别和运用的场景" class="headerlink" title="12. computed 和 watch 的区别和运用的场景"></a>12. computed 和 watch 的区别和运用的场景</h5><p>​    computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>​    watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>​    运用场景：<br>​    当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p>​    当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h5 id="13-过滤器的作用及用法"><a href="#13-过滤器的作用及用法" class="headerlink" title="13. 过滤器的作用及用法"></a>13. 过滤器的作用及用法</h5><p>​    用于一些常见的文本格式化，可用在双花括号插值和v-bind表达式两个地方。</p>
<p>​    用法上应该被添加在JavaScript边大师的尾部，由管道符指示，分为全局和本地，全局过滤器要在创建Vue实例之前全局定义过滤器，本地过滤器在一个组件的选项中定义。</p>
<h5 id="14-谈谈你对Vue生命周期的理解"><a href="#14-谈谈你对Vue生命周期的理解" class="headerlink" title="14. 谈谈你对Vue生命周期的理解"></a>14. 谈谈你对Vue生命周期的理解</h5><p>​    主要阶段有挂载 更新销毁，分别作用为初始化相关属性、元素或组件的变更操作以及销毁相关属性。</p>
<p>​    具体有beforeCreate  created  beforeMount  mounted  beforeUpdate  updated  beforeDestroy  destroyed；</p>
<p>​    其中beforeUpdate  updated是组件运行阶段的生命周期函数，这两个事件会根据data数据的改变，有选择性的触发0到多次；</p>
<p>​    在beforeCreate阶段中已经初始化了一个Vue空的实例对象，还没有data和methods；</p>
<p>​    在created中data与methods会被初始化好，如果要调用methods中的方法或者操作data中的数据，最早只能在created中；</p>
<p>​    beforeMount执行的时候，模板中已经在内存中编译好了，但是还没有挂载到页面中去；</p>
<p>​    mounted执行完之后，内存中编译好的模板将会被挂载到页面中去，如果要通过某些插件操作页面上的DOM节点，，最早要在mounted中进行，只要执行完了mounted就表示整个Vue实例已经初始化完毕了；</p>
<p>​    当执行beforeDestory的时候 Vue实例已经从运行阶段进入到了销毁阶段，实例中所有的data和methods以及过滤器 指令等还处于可用状态，在执行destroyed的时候，以上所有都已经被销毁掉，组件中的所有data methods 过滤器 指令等都不可再用了。</p>
<h5 id="15-在哪个生命周期内来调用异步请求"><a href="#15-在哪个生命周期内来调用异步请求" class="headerlink" title="15. 在哪个生命周期内来调用异步请求"></a>15. 在哪个生命周期内来调用异步请求</h5><p>​    created和mounted两个时期都可以</p>
<p>​    考虑用户体验方面的话，在created中调用异步请求最佳，用户就越早感知页面的已加载，毕竟越早获取数据，在mounted实例挂载的时候就越及时。</p>
<h5 id="16-谈谈你对vue组件的理解"><a href="#16-谈谈你对vue组件的理解" class="headerlink" title="16. 谈谈你对vue组件的理解"></a>16. 谈谈你对vue组件的理解</h5><p>​    组件的存在实现了对可重用代码的封装，且扩展了HTML标签的功能。组件之间是相互独立的，无法直接通信，但可以采用一定的办法进行通信。且组件之间可以嵌套，组件也能够被多次复用。</p>
<h5 id="17-Vue-js-组件中的-data-为什么是一个函数"><a href="#17-Vue-js-组件中的-data-为什么是一个函数" class="headerlink" title="17. Vue.js 组件中的 data 为什么是一个函数?"></a>17. Vue.js 组件中的 data 为什么是一个函数?</h5><p>​    为了保证组件复用时数据互不干扰，因为函数内返回的是一个未定义的对象，所以每次返回的对象地址都不一样，也就保证了组件之间数据的相互独立。</p>
<p>​    如果data返回的直接是是对象的话，多次使用同一个组件的话返回的地址都相同，那么就会出现data中数据共同变化的情况。</p>
<h5 id="18-vue组件间通信方式哪些？"><a href="#18-vue组件间通信方式哪些？" class="headerlink" title="18. vue组件间通信方式哪些？"></a>18. vue组件间通信方式哪些？</h5><p>​    有三类：分别是父组件向子组件传值、子组件向父组件传值以及兄弟之间的传值。</p>
<h5 id="19-组件插槽的作用、分类及使用场景？"><a href="#19-组件插槽的作用、分类及使用场景？" class="headerlink" title="19. 组件插槽的作用、分类及使用场景？"></a>19. 组件插槽的作用、分类及使用场景？</h5><p>​    1、组件插槽用于父组件向子组件传替模板内容，也算是一种父组件向子组件传值的通信方式。</p>
<p>​    2、有默认插槽、具名插槽和作用域插槽三种。</p>
<p>​    3、默认插槽用于子组件中需要使用两次及两次以上但个别部分不同的情况；当页面中引入多个插槽，就需要用到具名插槽来区分不同的插件；作用域插槽用于父组件对子组件的内容进行加工处理的场景，用的不是很多。</p>
<h5 id="20-为什么在vue中动态绑定src-图片要用require引入"><a href="#20-为什么在vue中动态绑定src-图片要用require引入" class="headerlink" title="20. 为什么在vue中动态绑定src 图片要用require引入"></a>20. 为什么在vue中动态绑定src 图片要用require引入</h5><p>​    动态绑定中路径会被加载器解析为字符串，导致图片找不到</p>
<h5 id="21-怎么理解vue的单项数据流"><a href="#21-怎么理解vue的单项数据流" class="headerlink" title="21. 怎么理解vue的单项数据流"></a>21. 怎么理解vue的单项数据流</h5><p>​    比如父组件向子组件传值，父组件传给子组件的值不能在子组件中被更改</p>
<h5 id="22-父组件可以监听到子组件的生命周期吗？"><a href="#22-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="22. 父组件可以监听到子组件的生命周期吗？"></a>22. 父组件可以监听到子组件的生命周期吗？</h5><p>​    可以 </p>
<p>​    使用on和emit，子组件emit触发事件，父组件on监听相应事件</p>
<p>​    使用hook生命周期钩子函数，在父组件中调用子组件的标签中定义@hook:mounted=‘事件名’，在子组件的mounted周期函数中写入所需操作，然后在父组件中即可监听到子组件mounted中的操作</p>
<h5 id="23-单文件组件有哪几部分组成？各有什么作用"><a href="#23-单文件组件有哪几部分组成？各有什么作用" class="headerlink" title="23. 单文件组件有哪几部分组成？各有什么作用"></a>23. 单文件组件有哪几部分组成？各有什么作用</h5><p>​    template script style三部分，都以双标签的形式存在</p>
<p>​    template部分用于存放页面html元素，</p>
<p>​    script部分存放文件所需的js部分代码，如需要导入的组件，data数据，计算属性，方法声明，以及异步请求的执行也是在该部分中</p>
<p>​    style部分存放页面的样式代码，</p>
<h5 id="24-vue-cli的作用"><a href="#24-vue-cli的作用" class="headerlink" title="24. vue-cli的作用"></a>24. vue-cli的作用</h5><p>​    可以使用命令行快速创建Vue项目，也可以通过Web界面进行项目的构建，还可以封装webpack</p>
<h5 id="25-创建vue项目有哪几种方式？"><a href="#25-创建vue项目有哪几种方式？" class="headerlink" title="25. 创建vue项目有哪几种方式？"></a>25. 创建vue项目有哪几种方式？</h5><p>​    两种，命令行创建和图形化界面创建</p>
<h5 id="26-如何创建和使用一个公共组件？"><a href="#26-如何创建和使用一个公共组件？" class="headerlink" title="26. 如何创建和使用一个公共组件？"></a>26. 如何创建和使用一个公共组件？</h5><p>​    在components目录下创建单文件组件</p>
<p>​    在需要使用的组件中使用import引入然后在template部分引入对应组件标签即可</p>
<h5 id="27-如何创建和使用一个全局方法？"><a href="#27-如何创建和使用一个全局方法？" class="headerlink" title="27. 如何创建和使用一个全局方法？"></a>27. 如何创建和使用一个全局方法？</h5><p>​    在assets目录的js目录下创建js文件将需要的方法定义在该js文件中，然后在main.js文件中引入该文件，</p>
<p>​    多页面使用的话，在需要使用该方法的页面中采用this.js文件名.方法名()的方式来使用。单文件使用就可以直接将其引入在该单页面中，然后采用js文件名.方法名()的方式来使用</p>
<h5 id="28-写过API接口吗？如何保存及更新token令牌"><a href="#28-写过API接口吗？如何保存及更新token令牌" class="headerlink" title="28. 写过API接口吗？如何保存及更新token令牌"></a>28. 写过API接口吗？如何保存及更新token令牌</h5><p>​    保存在localStorage中</p>
<p>​    更新的话，在生成token之后返回数据的时候将过期时间返回，然后在配置axios中将过期时间+存入token的时间存入localStorage作为expire，在token作成真正的同步之前进行token或者过期时间的判断，如果当前时间大于expire，便进行token的刷新</p>
<h5 id="29-什么是RestfulAPI"><a href="#29-什么是RestfulAPI" class="headerlink" title="29. 什么是RestfulAPI"></a>29. 什么是RestfulAPI</h5><p>​    目前最流行的接口设计规范，也是典型的基于HTTP的协议</p>
<p>​    最大的特点是通过URL来描述资源，但要遵守一定的规范，如路径上对资源的描述均使用名词不能使用动词。</p>
<h5 id="30-vue中如何解决ajax跨域请求问题"><a href="#30-vue中如何解决ajax跨域请求问题" class="headerlink" title="30. vue中如何解决ajax跨域请求问题"></a>30. vue中如何解决ajax跨域请求问题</h5><p>​    在开发模式下，使用proxy代理，在proxy中设置跨域，将域名发送给本地的服务器，再由本地的服务器去请求真正的服务器。</p>
<p>​    在生产模式下</p>
<p>​    使用jsonp：1、客户端将不同源的服务器端请求地址写在 script 标签的 src 属性中；2、服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数；3、在客户端全局作用域下定义接收数据的函数（函数名与服务器端传递的函数名相同），即可接收到跨域请求的数据</p>
<p>​    或者cors：通过在服务端响应头中指定允许访问的请求地址的方式解决跨域问题；此外还可express还可以通过安装 cors模块来实现跨域。然后在客户端直接请求接口即可。</p>
<p>​    以及Nginx</p>
<h5 id="31-Vue-cli-工程化都用到了哪些技术，它们的作用分别是什么"><a href="#31-Vue-cli-工程化都用到了哪些技术，它们的作用分别是什么" class="headerlink" title="31.  Vue-cli 工程化都用到了哪些技术，它们的作用分别是什么"></a>31.  Vue-cli 工程化都用到了哪些技术，它们的作用分别是什么</h5><p>​    1、vue.js：是vue-cli工程化的核心，主要特点是双向数据绑定和组件系统</p>
<p>​    2、vue-router：vue官方推荐使用的路由框架</p>
<p>​    3、vuex：Vue.js应用项目开发的状态管理器，主要用于维护vue组件公用的一些变量和方法</p>
<p>​    4、axios：基于Promise设计的用于发起GET或POST等http请求</p>
<p>​    5、webpack：模块加载和vue-cli工程打包器</p>
<h5 id="32-Vue-cli-常⽤的-npm-命令有哪些"><a href="#32-Vue-cli-常⽤的-npm-命令有哪些" class="headerlink" title="32. Vue-cli 常⽤的 npm 命令有哪些"></a>32. Vue-cli 常⽤的 npm 命令有哪些</h5><p>​    1、npm install 用于下载node_modules资源包</p>
<p>​    2、npm run dev 用于启动vue-cli2.0版本下 开发环境下的项目</p>
<p>​    3、npm run serve  用于启动vue-cli3.0版本下开发环境下的项目，</p>
<p>​    4、 npm run build 用于生成生产环境部署资源，即将项目打包，在vue-cli2.0版本下生成的是build文件，3.0下生成的是dist文件</p>
<p>​    5、npm run build–report 用于查看 vue-cli 生产环境部署资源文件大小</p>
<h5 id="33-Vue-中使用了哪些设计模式"><a href="#33-Vue-中使用了哪些设计模式" class="headerlink" title="33. Vue 中使用了哪些设计模式"></a>33. Vue 中使用了哪些设计模式</h5><p>设计模式就是为了解决具体场景下的问题</p>
<p>1、工厂模式-传入参数即可创建实例</p>
<p>​    虚拟DOM根据参数不同返回基础标签的Vnode和组件Vnode</p>
<p>2、单列模式-整个程序有且仅有一个实例</p>
<p>​    vuex和vue-router的插件注册方法install判断 如果系统存在实例就直接返回掉</p>
<p>3、发布-订阅者模式（vue事件机制）</p>
<p>4、观察者模式（响应式数据原理）</p>
<p>5、装饰模式（@装饰器的用法）</p>
<p>​    MVVM，这种设计模式本质上是对MVC的改版。将其中的View的状态和行为抽象化，让我们将视图和业务逻辑分开。</p>
<p>​    View层将指令传递给ViewModel，然后ViewModel进行与Model交互使其进行数据操作，操作成功后ViewModel将结果响应给View</p>
<h5 id="34-Vue路由模式有哪两种？区别是什么"><a href="#34-Vue路由模式有哪两种？区别是什么" class="headerlink" title="34.Vue路由模式有哪两种？区别是什么"></a>34.Vue路由模式有哪两种？区别是什么</h5><p>​    1、hash模式  即地址栏URL中的#符号，</p>
<p>​    2、history模式  利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）</p>
<p>​    区别：</p>
<p>​    hash只能改变#后边的url片段进行修改，而history 就很自由，可以进行切换和修改，使用go back forward进行前进后退，会用pushState 和 replaceState两个方法进行对历史状态的修改</p>
<h5 id="35-什么是懒加载路由"><a href="#35-什么是懒加载路由" class="headerlink" title="35.什么是懒加载路由"></a>35.什么是懒加载路由</h5><p>​    就是延迟加载或者按需加载，使用某个模块的时候才会加载，不使用便不加载</p>
<p>​    像vue这样的单页面应用不进行懒加载处理的话，在打包生成后的文件将会很大，用户进入首页时需要加载所有页面，就会出现首页加载速度过慢的问题</p>
<p>​    import </p>
<p>​    reslove</p>
<h5 id="36-声明式导航与编程式导航的区别"><a href="#36-声明式导航与编程式导航的区别" class="headerlink" title="36.声明式导航与编程式导航的区别"></a>36.声明式导航与编程式导航的区别</h5><p>​    都能进行导航 进行触发路由实现组件之间的切换，但写法不一样</p>
<p>​    1、声明式导航写在template 通过router-link，使用to进行跳转，后面可跟字符串、对象、命名路由等，用的最多还是直接跟路径</p>
<p>​    2、编程式导航写在js函数中 通过this.$router.push()，与声明式导航相同括号内可跟字符串 对象 命名路由等，一般还是直接使用路径进行跳转</p>
<h5 id="37-谈谈路由守卫（导航钩子）"><a href="#37-谈谈路由守卫（导航钩子）" class="headerlink" title="37.谈谈路由守卫（导航钩子）"></a>37.谈谈路由守卫（导航钩子）</h5><p>​    主要用于某些页面需要登录后才能访问，分为全局守卫和局部守卫</p>
<p>​    1、全局守卫挂载在router实例上，使用beforeEach方法进行使用，该方法有三个参数，分别是to from和next to是即将要进入的路由对象 from是当前导航正要离开的路由，next 要结束该方法就要调用next方法，否则不会进入下一个导航</p>
<p>​    2、局部守卫可以写在组件对用的路由配置中，也可以写在组件中，在路由配置中直接定义beforeEnter进行守卫，在组件中使用beforeRouteEnter不能访问this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建</p>
<h5 id="38-使用过mock吗？谈谈mock的作用及如何使用"><a href="#38-使用过mock吗？谈谈mock的作用及如何使用" class="headerlink" title="38.使用过mock吗？谈谈mock的作用及如何使用"></a>38.使用过mock吗？谈谈mock的作用及如何使用</h5><p>​    mock用于在后端API还没开发好的情况下去拦截请求，模拟真实API返回json数据</p>
<p>​    使用的话，首先安装mock插件，然后引入并设为全局属性，在需要使用的页面中使用Mock函数进行拦截设置即可</p>
<h5 id="39-谈谈你对Vuex的理解"><a href="#39-谈谈你对Vuex的理解" class="headerlink" title="39.谈谈你对Vuex的理解"></a>39.谈谈你对Vuex的理解</h5><p>​    1、vuex是一个专为vue.js应用程序开发的状态管理模式</p>
<p>​    2、vuex有五大核心概念，分别是state、getter、mutation、action、module。<br>​    state：存储数据、存储状态，在组件中可通过this.$store.state来访问；存放的数据是响应式的，vue组件从state中读取数据，如果数据发生变化，组件中对应的数据也会更新<br>​    getter：类似于计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算<br>​    actions：进行异步请求，并通过commit调用mutation间接更改vuex中的数据<br>​    mutation：用于更改store中state数据与状态<br>​    modules：将store分割成模块，每个模块都具有五大核心概念，在主模块中调用所有子模块</p>
<p>​    3、vuex的数据传递流程：在组件中通过dispatch调用actions进行异步操作，然后在actions中通过commit调用mutation进行对state中数据的更改，最后state中的数据得到更改然后响应到页面上</p>
<p>​    4、使用vuex进行对数据以及状态进行操作可以使代码变的更加结构化且易于维护</p>
<h5 id="40-Vuex五大核心概念是什么"><a href="#40-Vuex五大核心概念是什么" class="headerlink" title="40.Vuex五大核心概念是什么"></a>40.Vuex五大核心概念是什么</h5><p>​    分别是state、getters、mutations、actions、modules</p>
<p>​    1、state：存储数据，存储状态；在vue组件中用 this.$store.state 来访问；对应vue里面的data，存放数据方式为响应式，vue组件从store中读取数据，如数据发生变化，组件也会对应的更新。</p>
<p>​    2、getters：类似于计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p>
<p>​    3、actions：进行异步请求，并通过commit调用mutation间接更改vuex中的数据</p>
<p>​    4、mutations：用于更改store中state数据与状态</p>
<p>​    5、modules：将store分割成模块，每个模块都具有五大核心概念，在主模块中调用所有子模块</p>
<h5 id="41-Vuex与本地存储的区别"><a href="#41-Vuex与本地存储的区别" class="headerlink" title="41.Vuex与本地存储的区别"></a>41.Vuex与本地存储的区别</h5><p>​    1、存储方式不同：vuex存储在内存中，页面的刷新会将更改的数据重置；本地存储中的localStorage是以文件的形式存储在本地，永久保存，不会随着页面的刷新而将数据清除或重置，本地存储中的sessionStorage是会话存储，是临时保存，页面关闭后就会被清除掉</p>
<p>​    2、应用场景不同：vuex用于组件之间的传值，而本地存储用于不同页面之间的传值</p>
<h5 id="42-如何解决Vuex中数据页面刷新重置的问题"><a href="#42-如何解决Vuex中数据页面刷新重置的问题" class="headerlink" title="42.如何解决Vuex中数据页面刷新重置的问题"></a>42.如何解决Vuex中数据页面刷新重置的问题</h5><p>​    在页面刷新之前将数据存到localStorage或sessionStorage中</p>
<p>​    在每次进入到页面的时候进行数据的初始化，每次进行数据的更改的同时也进行对数据库的操作，然后同步vuex中的数据</p>
<h5 id="43-谈谈Vue中axios的使用"><a href="#43-谈谈Vue中axios的使用" class="headerlink" title="43.谈谈Vue中axios的使用"></a>43.谈谈Vue中axios的使用</h5><p>​    用于访问API并展示其数据</p>
<p>​    首先要使用npm安装axios ，然后创建axios.js文件进行对axios的封装，要将其文件在main.js中引入，在封装的文件中需要导入Vue axios以及Vue-axios，并将Vue设为全局属性，然后进行axios的各种设置，比如默认API地址的设置，请求拦截的设置，如果用到token，也是在请求拦截中进行获取以及操作，然后就是响应拦截的设置</p>
<h5 id="44-请说出Vue-cli项目中src目录下主要目录和文件的作用？"><a href="#44-请说出Vue-cli项目中src目录下主要目录和文件的作用？" class="headerlink" title="44.请说出Vue.cli项目中src目录下主要目录和文件的作用？"></a>44.请说出Vue.cli项目中src目录下主要目录和文件的作用？</h5><p>​    main.js：项目的入口文件，在此引入项目所需要的各种第三方插件以及自定义的文件，并进行路由注册，且引入store，并渲染好指定组件将内容挂载到id为app的地方去</p>
<p>​    App.vue：是项目的应用主组件，所有单文件组件都会通过main.js渲染并挂载到该组件中</p>
<p>​    /views：放置各种视图组件</p>
<p>​    /components：放置公共组件</p>
<p>​    /router：放置进行路由配置的路由文件</p>
<p>​    /store：放置vuex文件</p>
<p>​    /assets：放置静态资源文件</p>
<p>​    /plugins：放置插件资源文件，在main.js中被引用</p>
<h5 id="45-Vue中keep-alive的作用"><a href="#45-Vue中keep-alive的作用" class="headerlink" title="45.Vue中keep-alive的作用"></a>45.Vue中keep-alive的作用</h5><p>​    keep-live用来缓存组件，避免多次加载响应的组件，减少性能消耗，比如从页面一链接到页面二再返回到页面一时不用重新再加载页面一的内容，因为页面一的内容已经存在了缓存中</p>
<h5 id="46-active-class是哪个组件的属性"><a href="#46-active-class是哪个组件的属性" class="headerlink" title="46.active-class是哪个组件的属性"></a>46.active-class是哪个组件的属性</h5><p>​    是vue-router模块中声明式导航router-link组件中的属性，用来做选中状态的高亮显示</p>
<p>​    在该属性上设置值然后在样式中直接写样式即可</p>
<h5 id="47-怎么定义Vue-router的动态路由以及如何获取传过来的动态参数"><a href="#47-怎么定义Vue-router的动态路由以及如何获取传过来的动态参数" class="headerlink" title="47.怎么定义Vue-router的动态路由以及如何获取传过来的动态参数"></a>47.怎么定义Vue-router的动态路由以及如何获取传过来的动态参数</h5><p>​    有query和params两种方式</p>
<p>​    1、query：传递的时候在对象中使用query的key作为传递方式或者直接拼在path后，传递后的参数会统一拼在路径后，可以使用$route.query来获取传递的值</p>
<p>​    2、params：配置路由路径的时候在后面拼上需要传递的参数名，传递的时候在path后跟上对应的值，用$route.params来获取传递的参数</p>
<h5 id="48-Vue过渡如何实现"><a href="#48-Vue过渡如何实现" class="headerlink" title="48.Vue过渡如何实现"></a>48.Vue过渡如何实现</h5><p>​    Vue有内置的过渡封装组件，使用的时候将需要过渡的部分用transtion组件标签包裹，默认有六个class的切换，分别是v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to，分别控制元素进入或离开的开始状态、生效时的状态以及结束状态</p>
<p>​    多元素过渡时需要在每个元素上添加key值</p>
<h5 id="49-Vue动画如何实现"><a href="#49-Vue动画如何实现" class="headerlink" title="49.Vue动画如何实现"></a>49.Vue动画如何实现</h5><p>​    可以使用内置的动画封装组件也可以引入第三方插件</p>
<p>​    1、使用内置的动画封装组件时需要将有动画的部分用transtion标签包括，使用v-enter-active 指定显示的transition    进入，v-leave-active 指定显示的transition 离开</p>
<p>​    2、引入animate.css第三方库，或安装第三方库，在需要使用的地方写入动画的name，使用enter-active-class和leave-active-class设置需要的动画</p>
<h5 id="50-Vue多元素过渡如何实现"><a href="#50-Vue多元素过渡如何实现" class="headerlink" title="50.Vue多元素过渡如何实现"></a>50.Vue多元素过渡如何实现</h5><p>​    在transtion-group组件标签包括在内的每个元素设置不同的key值用于区分不同的元素</p>
<h5 id="51-Vue第三方动画如何实现"><a href="#51-Vue第三方动画如何实现" class="headerlink" title="51.Vue第三方动画如何实现"></a>51.Vue第三方动画如何实现</h5><p>​    引入animate.css第三方库，或安装第三方库，在需要使用的地方写入动画的name，使用enter-active-class和leave-active-class设置需要的动画</p>
<h5 id="52-nextTick的作用、实现原理以及使用场景"><a href="#52-nextTick的作用、实现原理以及使用场景" class="headerlink" title="52.nextTick的作用、实现原理以及使用场景"></a>52.nextTick的作用、实现原理以及使用场景</h5><p>​    1、作用：在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的DOM；相当于一个延迟的作用</p>
<p>​    2、实现原理：nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p>
<p>​    3、使用场景：用在一切DOM还没更新完成的场景中</p>
<h5 id="53-描述Vue中webpack常用配置"><a href="#53-描述Vue中webpack常用配置" class="headerlink" title="53.描述Vue中webpack常用配置"></a>53.描述Vue中webpack常用配置</h5><p>​    1、在package.json中设置webpack的mode</p>
<p>​    2、在vue.config.js判断环境是生产环境还是开发环境，进行相应的配置，在生产环境下可以关闭语法书写规范的检查，如果不需要生产环境的source map，可以将其设置为false以加速生产环境的构建；在开发环境下也可以关闭语法书写规范的检查，并且设置热启动，如端口号、用于跨域的代理等</p>
<p>​    3、在axios.js中配置默认的API地址</p>
<h5 id="54-Vue项目优化方法有哪些"><a href="#54-Vue项目优化方法有哪些" class="headerlink" title="54.Vue项目优化方法有哪些"></a>54.Vue项目优化方法有哪些</h5><p>​    首先生成打包报告，查看哪些占用空间比较大的插件。</p>
<p>​    1、第三方库启用CDN，默认情况下通过import语法导入第三方依赖包，最后会被打包合并到统一文件中，从而导致打包后单个文件体积过大的问题；</p>
<p>​    启用CDN的，首先在配置文件中将第三方依赖包声明在externals中，然后在index.html中通过CDN在线网址引入各种插件，这样第三方包就不会被打包合并，不过有个缺点就是不太稳定</p>
<p>​    2、element-ui/mint-ui组件按需加载</p>
<p>​    3、路由懒加载</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params"></span>) =&gt; <span class="title function_">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">方式二：</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是你的模块 不用import去引入了</span></span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4、图片懒加载</p>
<p>​    安装lazy-load，进行全局注册，v-lazy=“”使用</p>
<h5 id="55-Vue项目上线部署方式有哪些"><a href="#55-Vue项目上线部署方式有哪些" class="headerlink" title="55.Vue项目上线部署方式有哪些"></a>55.Vue项目上线部署方式有哪些</h5><p>express方式：</p>
<p>​    1、创建web服务器</p>
<p>​    新建项目目录并初始化npm配置，然后安装express框架，将打包生成的dist目录拷贝到项目目录下，创建app.js文件，利用express创建web服务（配置静态资源托管中间件并配置端口）</p>
<p>​    2、开启文件的gzip网络传输压缩（使用gizp可以减少文件网络传输时的体积，加快传输速度，让网页更快的显示）</p>
<p>​    3、配置HTTPS服务（使用HTTPS服务更加安全可靠）</p>
<h5 id="56-用过哪些Vue相关的UI框架？使用过它们的哪些功能"><a href="#56-用过哪些Vue相关的UI框架？使用过它们的哪些功能" class="headerlink" title="56.用过哪些Vue相关的UI框架？使用过它们的哪些功能"></a>56.用过哪些Vue相关的UI框架？使用过它们的哪些功能</h5><p>​    element-ui和mint-ui，都是饿了么团队开发的ui框架</p>
<p>​    1、PC端使用element-ui，比较经常用它的导航菜单、标签页、日历、alert警告框，message消息提示，messageBox弹框等功能</p>
<p>​    2、mint-ui是一个支持移动端的的ui框架，在写电商网站加入购物车的功能有用到popup这个功能，还有首页的无限加载有用到loadmore以及indicator，各种提示信息会用到toast，除此之外还常用到swiper进行图片的轮播展示</p>
<h5 id="57-vue防抖和节流是什么"><a href="#57-vue防抖和节流是什么" class="headerlink" title="57.vue防抖和节流是什么"></a>57.vue防抖和节流是什么</h5><p>解决事件高频触发，都保证了单位时间内只会触发一次事件</p>
<p>​    1、防抖：触发高频事件n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间；因为防抖的特性，一直执行最后一次的触发，所以可以用于鼠标移动确定最后一次移动的时候的坐标位置。</p>
<p>​    2、节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率；因为节流是监听到第一次触发事件后就执行，所以可以用来防止按钮多次点击执行多次，且按照第一次点击的事件为准</p>
<h5 id="58-Vue中-route-和-router-的区别"><a href="#58-Vue中-route-和-router-的区别" class="headerlink" title="58.Vue中$route 和 $router 的区别"></a>58.Vue中$route 和 $router 的区别</h5><p>​    1、route是指当前页面的路由信息，包含了当前URL解析得到的信息，比如路径、参数、query对象等</p>
<p>​    2、router是全局路由的实例，是router构造方法的实例，包含了所有路由信息，主要用于页面的跳转</p>
<h5 id="59-Vue中事件绑定的原理"><a href="#59-Vue中事件绑定的原理" class="headerlink" title="59.Vue中事件绑定的原理"></a>59.Vue中事件绑定的原理</h5><p>​    Vue中事件绑定有两种，一种是原生的事件绑定，另一种是组件的事件绑定$on</p>
<p>​    1、原生的事件绑定在普通元素上是通过addEventListener进行绑定;</p>
<p>​    2、在组件上是通过@click.native进行绑定,组件的事件绑定的@click是vue中自定义的 <code>$on</code>方法来实现的，必须有<code>$emit</code>才可以触发； </p>
<h5 id="60-Vue中相同逻辑如何抽离"><a href="#60-Vue中相同逻辑如何抽离" class="headerlink" title="60.Vue中相同逻辑如何抽离"></a>60.Vue中相同逻辑如何抽离</h5><p>​    使用Vue.mixin方法（混入），其提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。</p>
<p>​    小程序中的behaviors，类似mixin、traits</p>
<h5 id="61-什么是服务器端渲染-SSR"><a href="#61-什么是服务器端渲染-SSR" class="headerlink" title="61.什么是服务器端渲染 (SSR)"></a>61.什么是服务器端渲染 (SSR)</h5><p>​    1、是服务端生成静态的HTML字符串，浏览器将静态标记“混合“为客户端可交互的应用程序</p>
<p>​    2、服务器渲染的Vue.js应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行</p>
<p>​    3、与传统的SPA相比，服务端渲染的优势主要在于：更好的seo和加快首屏加载速度</p>
<p>​    4、代价：开发条件首先monted，构建部署要求多，服务器负载会变大</p>
<p>​    5、实现：vue-server-render  express</p>
<h5 id="62-Vue3和Vue2相比有哪些变化"><a href="#62-Vue3和Vue2相比有哪些变化" class="headerlink" title="62.Vue3和Vue2相比有哪些变化"></a>62.Vue3和Vue2相比有哪些变化</h5><p>​    1、性能的提升：打包大小减少41%，除此渲染快55%，更新渲染快133%，内存减少54%</p>
<p>​    2、源码的升级：使用Proxy代替defineProperty实现响应式，重写虚拟DOM的实现，webpack中使用了Tree-Shaking技术</p>
<p>​    3、更好的支持TypeScript</p>
<p>​    4、有新的特性：（1）组合式API（2）组件的多根节点支持                        （3）新的内置组件 Fragment Teleport Suspense （4）生命周期钩子函数的变化</p>
<p>​    5、废弃了一些功能：移除了keyCode支持作为v-on的修饰符；废弃了过滤器</p>
<h5 id="63-创建Vue3工程的方式有哪些"><a href="#63-创建Vue3工程的方式有哪些" class="headerlink" title="63.创建Vue3工程的方式有哪些"></a>63.创建Vue3工程的方式有哪些</h5><p>​    1、使用vue-cli创建：需要vue-cli版本在4.5.0以上</p>
<p>​    2、使用vite创建：vite是新一代前端构建工具，有以下优势：在开发环境在无需打包操作，可快速的冷启动；轻量快速的热重载；真正的按需编译，不会再等待整个应用编译完成</p>
<h5 id="64-谈谈你对Composition-API（组合式API-的理解"><a href="#64-谈谈你对Composition-API（组合式API-的理解" class="headerlink" title="64.谈谈你对Composition API（组合式API)的理解"></a>64.谈谈你对Composition API（组合式API)的理解</h5><p>​    1、是一组低入侵式的，函数式的API，是的我们能够更灵活的组合组件的逻辑</p>
<p>​    2、有一定的优点和缺点：组合式API不再像以前那样对代码进行了强制性的分割，代码组织非常灵活。但对新手来说，在逻辑越来越复杂的情况下，setup的代码量会越来越多，同时setup内的return也越来越多，将会落入到面条代码之中</p>
<h5 id="65-Vue3和Vue2的响应式系统有什么不同"><a href="#65-Vue3和Vue2的响应式系统有什么不同" class="headerlink" title="65.Vue3和Vue2的响应式系统有什么不同"></a>65.Vue3和Vue2的响应式系统有什么不同</h5><p>​    1、Vue2响应式的核心是通过defineProperty方法进行对已有属性值读取和修改的劫持而实现的</p>
<p>​    2、Vue3响应式是通过Proxy代理拦截对data任意属性的任意操作进行实现的</p>
<h5 id="66-ref和reactive的作用"><a href="#66-ref和reactive的作用" class="headerlink" title="66.ref和reactive的作用"></a>66.ref和reactive的作用</h5><p>​    1、ref函数：定义一个基本数据类型的响应式数据，依靠Object.defineProperty()的get与set完成的；；.value</p>
<p>​    2、reactive函数：定义一个对象类型的响应式数据，基于Proxy实现数据劫持，通过代理对象操作源对象内部数据进行操作</p>
<h5 id="67-toRef与toRefs的作用"><a href="#67-toRef与toRefs的作用" class="headerlink" title="67.toRef与toRefs的作用"></a>67.toRef与toRefs的作用</h5><p>​    1、toRef：将响应式对象的某个属性单独提供给外部使用，使用时接收两个参数，第一个参数是对象的名称，第二个参数是要提供给外部的对象的属性</p>
<p>​    2、toRefs：将响应式对象所有属性都设置为可供外部单独使用，使用时接受一个对象作为参数即可，它会遍历对象身上的所有属性，然后挨个调用toRef执行,加上…扩展运算符</p>
<h5 id="68-Vue3中的生命周期函数有哪些变化"><a href="#68-Vue3中的生命周期函数有哪些变化" class="headerlink" title="68.Vue3中的生命周期函数有哪些变化"></a>68.Vue3中的生命周期函数有哪些变化</h5><p>​    Vue3中用setup代替了Vue2的beforeCreate和created两个周期函数，Vue3中用onBeforeMount代替了Vue2的beforeMount周期函数；除此之外还有以下改变情况，使用的时候</p>
<p><code>mounted ----&gt;onMounted</code></p>
<p><code>beforeUpdate ----&gt;onBeforeUpdate</code></p>
<p><code>updated ----&gt;onUpdated</code></p>
<p><code>beforeDestory ----&gt;onBeforeUnmount</code></p>
<p><code>destoryed ----&gt;onUnmounted</code></p>
<h5 id="69-组件式API中setup函数有哪些参数，各有什么作用"><a href="#69-组件式API中setup函数有哪些参数，各有什么作用" class="headerlink" title="69.组件式API中setup函数有哪些参数，各有什么作用"></a>69.组件式API中setup函数有哪些参数，各有什么作用</h5><p>​    1、props参数：包含组件外部传递过来且组件内部声明接收了的属性；比如父组件通过属性给子组件传值，子组件通过props参数接收</p>
<p>​    2、context参数：是上下文对象，含有三部分：attrs包含组件外部传递过来但没有在props配置中声明的属性,相当于<code>this.$attrs</code>；slots包含收到的插槽内容相当于<code>this.$slots</code>;emit包含分发自定义事件的函数，相当于<code>this.$emit</code></p>
<h5 id="70-provide-与-inject的作用"><a href="#70-provide-与-inject的作用" class="headerlink" title="70.provide 与 inject的作用"></a>70.provide 与 inject的作用</h5><p>​    1、实现组件与后代组件间的通信</p>
<p>​    2、父组件使用provide选项来提供数据，后代组件使用inject选项来使用这些数据</p>
<p>（使用特别多）</p>
<h5 id="71-什么是hook"><a href="#71-什么是hook" class="headerlink" title="71.什么是hook"></a>71.什么是hook</h5><p>​    1、本质是一个函数，把setup函数中使用的组合式API进行了封装，类似于Vue2中的mixin</p>
<p>​    2、Vue3中使用自定义hook可以将复用代码进行封装，让setup中的逻辑更清楚易懂</p>
<p>​    3、使用：在src目录下新建hook目录，下面创建自定义文件，创建完成后在需要使用的组件中先使用import进行导入，然后即可使用</p>
<h5 id="72-Vue3中Fragment新组件的作用"><a href="#72-Vue3中Fragment新组件的作用" class="headerlink" title="72.Vue3中Fragment新组件的作用"></a>72.Vue3中Fragment新组件的作用</h5><p>​    1、作为虚拟根标签的一种存在，可以让组件没有根标签</p>
<p>​    2、可以减少标签层级，减小内存占用</p>
<h5 id="73-Vue3中Teleport新组件的作用"><a href="#73-Vue3中Teleport新组件的作用" class="headerlink" title="73.Vue3中Teleport新组件的作用"></a>73.Vue3中Teleport新组件的作用</h5><p>​    1、是一种能够将我们组件html结构移动到指定位置的技术</p>
<p>​    2、比如弹层就可以使用该技术，弹层不需要的使用将其移动到body下</p>
<h5 id="74-Vue3中Suspense新组件的作用"><a href="#74-Vue3中Suspense新组件的作用" class="headerlink" title="74.Vue3中Suspense新组件的作用"></a>74.Vue3中Suspense新组件的作用</h5><p>​    1、等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
<p>​    2、使用时要先引入defineAsyncComponent和子组件，然后使用suspense包裹组件并配置好default和fallback即可</p>
<h5 id="75-Composition-API和option-API优劣对比"><a href="#75-Composition-API和option-API优劣对比" class="headerlink" title="75.Composition API和option API优劣对比"></a>75.Composition API和option API优劣对比</h5><p>​    1、Composition API不像option API那样将代码的各部分进行分割，而是将所有代码都写进了setup中，所以代码组织变的非常灵活</p>
<p>​    2、在进行代码修改的时候，Composition API更加的有条理更加的方便</p>
<p>​    3、Componsition API中没有对this的使用，减少了this指向不明的情况</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/weixin.gif" alt="亚丽 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/zhifubao.gif" alt="亚丽 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2017/05/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="next" title="小程序-面试题">
      小程序-面试题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9vue%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">1.  谈谈你对vue的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">2. 说说你对 SPA 单页面的理解，它的优缺点分别是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9MVC%E3%80%81MVP%E3%80%81MVVM%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">3.  谈谈你对MVC、MVP、MVVM的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">4. 双向绑定原理分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%99%9A%E6%8B%9Fdom%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">5.  虚拟dom的实现原理及优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%B8%B8%E7%94%A8%E7%9A%84vue%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">6.</span> <span class="nav-text">6. 常用的vue指令有哪些，各有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">7. 常用的事件修饰符有哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-v-if%E5%92%8Cv-show%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">8. v-if和v-show的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-v-for%E4%B8%AD%E7%9A%84key%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">9.</span> <span class="nav-text">9. v-for中的key属性的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-v-for%E5%92%8Cv-if-%E8%B0%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="nav-number">10.</span> <span class="nav-text">10. v-for和v-if 谁优先级高，为什么不建议一起用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E6%A0%B7%E5%BC%8FClass-%E4%B8%8E-Style"><span class="nav-number">11.</span> <span class="nav-text">11. 如何动态绑定样式Class 与 Style</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#12-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%BF%90%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-number">12.</span> <span class="nav-text">12. computed 和 watch 的区别和运用的场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#13-%E8%BF%87%E6%BB%A4%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95"><span class="nav-number">13.</span> <span class="nav-text">13. 过滤器的作用及用法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#14-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">14.</span> <span class="nav-text">14. 谈谈你对Vue生命周期的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#15-%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%86%85%E6%9D%A5%E8%B0%83%E7%94%A8%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">15.</span> <span class="nav-text">15. 在哪个生命周期内来调用异步请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#16-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9vue%E7%BB%84%E4%BB%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">16.</span> <span class="nav-text">16. 谈谈你对vue组件的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#17-Vue-js-%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="nav-number">17.</span> <span class="nav-text">17. Vue.js 组件中的 data 为什么是一个函数?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#18-vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">18.</span> <span class="nav-text">18. vue组件间通信方式哪些？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#19-%E7%BB%84%E4%BB%B6%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">19. 组件插槽的作用、分类及使用场景？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#20-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8vue%E4%B8%AD%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Asrc-%E5%9B%BE%E7%89%87%E8%A6%81%E7%94%A8require%E5%BC%95%E5%85%A5"><span class="nav-number">20.</span> <span class="nav-text">20. 为什么在vue中动态绑定src 图片要用require引入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#21-%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3vue%E7%9A%84%E5%8D%95%E9%A1%B9%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">21.</span> <span class="nav-text">21. 怎么理解vue的单项数据流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#22-%E7%88%B6%E7%BB%84%E4%BB%B6%E5%8F%AF%E4%BB%A5%E7%9B%91%E5%90%AC%E5%88%B0%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%90%97%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">22. 父组件可以监听到子组件的生命周期吗？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#23-%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E5%87%A0%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%EF%BC%9F%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">23.</span> <span class="nav-text">23. 单文件组件有哪几部分组成？各有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#24-vue-cli%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">24.</span> <span class="nav-text">24. vue-cli的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#25-%E5%88%9B%E5%BB%BAvue%E9%A1%B9%E7%9B%AE%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">25.</span> <span class="nav-text">25. 创建vue项目有哪几种方式？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#26-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">26. 如何创建和使用一个公共组件？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#27-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">27.</span> <span class="nav-text">27. 如何创建和使用一个全局方法？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#28-%E5%86%99%E8%BF%87API%E6%8E%A5%E5%8F%A3%E5%90%97%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%8F%8A%E6%9B%B4%E6%96%B0token%E4%BB%A4%E7%89%8C"><span class="nav-number">28.</span> <span class="nav-text">28. 写过API接口吗？如何保存及更新token令牌</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#29-%E4%BB%80%E4%B9%88%E6%98%AFRestfulAPI"><span class="nav-number">29.</span> <span class="nav-text">29. 什么是RestfulAPI</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#30-vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3ajax%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98"><span class="nav-number">30.</span> <span class="nav-text">30. vue中如何解决ajax跨域请求问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#31-Vue-cli-%E5%B7%A5%E7%A8%8B%E5%8C%96%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">31.</span> <span class="nav-text">31.  Vue-cli 工程化都用到了哪些技术，它们的作用分别是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#32-Vue-cli-%E5%B8%B8%E2%BD%A4%E7%9A%84-npm-%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">32.</span> <span class="nav-text">32. Vue-cli 常⽤的 npm 命令有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#33-Vue-%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">33.</span> <span class="nav-text">33. Vue 中使用了哪些设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#34-Vue%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%EF%BC%9F%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">34.</span> <span class="nav-text">34.Vue路由模式有哪两种？区别是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#35-%E4%BB%80%E4%B9%88%E6%98%AF%E6%87%92%E5%8A%A0%E8%BD%BD%E8%B7%AF%E7%94%B1"><span class="nav-number">35.</span> <span class="nav-text">35.什么是懒加载路由</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#36-%E5%A3%B0%E6%98%8E%E5%BC%8F%E5%AF%BC%E8%88%AA%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">36.声明式导航与编程式导航的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#37-%E8%B0%88%E8%B0%88%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%EF%BC%88%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%89"><span class="nav-number">37.</span> <span class="nav-text">37.谈谈路由守卫（导航钩子）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#38-%E4%BD%BF%E7%94%A8%E8%BF%87mock%E5%90%97%EF%BC%9F%E8%B0%88%E8%B0%88mock%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-number">38.</span> <span class="nav-text">38.使用过mock吗？谈谈mock的作用及如何使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#39-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Vuex%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">39.</span> <span class="nav-text">39.谈谈你对Vuex的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#40-Vuex%E4%BA%94%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">40.</span> <span class="nav-text">40.Vuex五大核心概念是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#41-Vuex%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">41.</span> <span class="nav-text">41.Vuex与本地存储的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#42-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Vuex%E4%B8%AD%E6%95%B0%E6%8D%AE%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E9%87%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">42.</span> <span class="nav-text">42.如何解决Vuex中数据页面刷新重置的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#43-%E8%B0%88%E8%B0%88Vue%E4%B8%ADaxios%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">43.</span> <span class="nav-text">43.谈谈Vue中axios的使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#44-%E8%AF%B7%E8%AF%B4%E5%87%BAVue-cli%E9%A1%B9%E7%9B%AE%E4%B8%ADsrc%E7%9B%AE%E5%BD%95%E4%B8%8B%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">44.</span> <span class="nav-text">44.请说出Vue.cli项目中src目录下主要目录和文件的作用？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#45-Vue%E4%B8%ADkeep-alive%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">45.</span> <span class="nav-text">45.Vue中keep-alive的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#46-active-class%E6%98%AF%E5%93%AA%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">46.</span> <span class="nav-text">46.active-class是哪个组件的属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#47-%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89Vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="nav-number">47.</span> <span class="nav-text">47.怎么定义Vue-router的动态路由以及如何获取传过来的动态参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#48-Vue%E8%BF%87%E6%B8%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">48.</span> <span class="nav-text">48.Vue过渡如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#49-Vue%E5%8A%A8%E7%94%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">49.</span> <span class="nav-text">49.Vue动画如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#50-Vue%E5%A4%9A%E5%85%83%E7%B4%A0%E8%BF%87%E6%B8%A1%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">50.</span> <span class="nav-text">50.Vue多元素过渡如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#51-Vue%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8A%A8%E7%94%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">51.</span> <span class="nav-text">51.Vue第三方动画如何实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#52-nextTick%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">52.</span> <span class="nav-text">52.nextTick的作用、实现原理以及使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#53-%E6%8F%8F%E8%BF%B0Vue%E4%B8%ADwebpack%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">53.</span> <span class="nav-text">53.描述Vue中webpack常用配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#54-Vue%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">54.</span> <span class="nav-text">54.Vue项目优化方法有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#55-Vue%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">55.</span> <span class="nav-text">55.Vue项目上线部署方式有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#56-%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9BVue%E7%9B%B8%E5%85%B3%E7%9A%84UI%E6%A1%86%E6%9E%B6%EF%BC%9F%E4%BD%BF%E7%94%A8%E8%BF%87%E5%AE%83%E4%BB%AC%E7%9A%84%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD"><span class="nav-number">56.</span> <span class="nav-text">56.用过哪些Vue相关的UI框架？使用过它们的哪些功能</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#57-vue%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">57.</span> <span class="nav-text">57.vue防抖和节流是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#58-Vue%E4%B8%AD-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">58.</span> <span class="nav-text">58.Vue中$route 和 $router 的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#59-Vue%E4%B8%AD%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">59.</span> <span class="nav-text">59.Vue中事件绑定的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#60-Vue%E4%B8%AD%E7%9B%B8%E5%90%8C%E9%80%BB%E8%BE%91%E5%A6%82%E4%BD%95%E6%8A%BD%E7%A6%BB"><span class="nav-number">60.</span> <span class="nav-text">60.Vue中相同逻辑如何抽离</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#61-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-SSR"><span class="nav-number">61.</span> <span class="nav-text">61.什么是服务器端渲染 (SSR)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#62-Vue3%E5%92%8CVue2%E7%9B%B8%E6%AF%94%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96"><span class="nav-number">62.</span> <span class="nav-text">62.Vue3和Vue2相比有哪些变化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#63-%E5%88%9B%E5%BB%BAVue3%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">63.</span> <span class="nav-text">63.创建Vue3工程的方式有哪些</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#64-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9Composition-API%EF%BC%88%E7%BB%84%E5%90%88%E5%BC%8FAPI-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">64.</span> <span class="nav-text">64.谈谈你对Composition API（组合式API)的理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#65-Vue3%E5%92%8CVue2%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C"><span class="nav-number">65.</span> <span class="nav-text">65.Vue3和Vue2的响应式系统有什么不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#66-ref%E5%92%8Creactive%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">66.</span> <span class="nav-text">66.ref和reactive的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#67-toRef%E4%B8%8EtoRefs%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">67.</span> <span class="nav-text">67.toRef与toRefs的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#68-Vue3%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%98%E5%8C%96"><span class="nav-number">68.</span> <span class="nav-text">68.Vue3中的生命周期函数有哪些变化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#69-%E7%BB%84%E4%BB%B6%E5%BC%8FAPI%E4%B8%ADsetup%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%8C%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="nav-number">69.</span> <span class="nav-text">69.组件式API中setup函数有哪些参数，各有什么作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#70-provide-%E4%B8%8E-inject%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">70.</span> <span class="nav-text">70.provide 与 inject的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#71-%E4%BB%80%E4%B9%88%E6%98%AFhook"><span class="nav-number">71.</span> <span class="nav-text">71.什么是hook</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#72-Vue3%E4%B8%ADFragment%E6%96%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">72.</span> <span class="nav-text">72.Vue3中Fragment新组件的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#73-Vue3%E4%B8%ADTeleport%E6%96%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">73.</span> <span class="nav-text">73.Vue3中Teleport新组件的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#74-Vue3%E4%B8%ADSuspense%E6%96%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">74.</span> <span class="nav-text">74.Vue3中Suspense新组件的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#75-Composition-API%E5%92%8Coption-API%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94"><span class="nav-number">75.</span> <span class="nav-text">75.Composition API和option API优劣对比</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="亚丽"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">亚丽</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/wuyali-6666" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wuyali-6666" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:wyl2191854028@163.com" title="E-Mail → mailto:wyl2191854028@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">亚丽</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>

<script color="0,0,0" opacity='0.8' zIndex="-2" count="200" type="text/javascript" src="/js/canvas-nest.min.js"></script>

</html>
