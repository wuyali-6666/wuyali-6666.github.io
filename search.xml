<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ES6-面试题</title>
    <url>/2017/05/26/ES6-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="1、说一下你所知道的es6-新特性"><a href="#1、说一下你所知道的es6-新特性" class="headerlink" title="1、说一下你所知道的es6+新特性"></a>1、说一下你所知道的es6+新特性</h5><p>​    1、新增let、const</p>
<p>​    2、解构赋值：可以按照一定模式从数组和对象中提取值赋值给变量</p>
<p>​    3、模板字符串：是增强版的字符串，用反引号标识，字符串中可以识别空格、换行、单引、双引；可以使用${}的形式输出变量以及使用函数和运算符</p>
<p>​    4、简化了对象的写法：允许在大括号里面直接写入变量和函数作为对象的属性和方法；允许在对象中声明方法时省去funcition</p>
<p>​    5、用箭头函数简化了匿名函数写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">函数无参数</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">函数有一个参数</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = x =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line">函数有多个参数</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params">x,y</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x+y)</span><br><span class="line">&#125;</span><br><span class="line">函数只有一条语句</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">test</span> = (<span class="params">x,y</span>) =&gt; x + y;</span><br></pre></td></tr></table></figure>

<p>​    6、rest参数：用来代替arguments接收参数，适合于函数实参个数不确定的场景</p>
<p>​    7、spread扩展运算符：用于对数组进行解包，将一个数组转为用逗号分隔的参数序列</p>
<p>​    8、promise对象：是一种异步编程的解决方案，语法上是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果</p>
<p>​    9、模块化：先自定义的模块进行暴露，然后在app.js中引入</p>
<p>​    10、Class类：</p>
<h5 id="2、var、let、const之间的区别"><a href="#2、var、let、const之间的区别" class="headerlink" title="2、var、let、const之间的区别"></a>2、var、let、const之间的区别</h5><p>​    1、var和let声明的是变量，const声明的是常量，常量：声明的同时必须赋值，一旦声明赋值之后不可以被更改，但是数组或对象可以更改，支持块级作用域</p>
<p>​    2、var声明的是函数作用域或全局作用域，let声明的是块级作用域</p>
<p>​    3、var声明的变量有变量提升，let声明的变量没有</p>
<p>​    4、var可以重新声明变量，let不可以重新声明</p>
<p>​    5、var声明的全局变量是window对象属性，let声明的变量不是</p>
<h5 id="3、箭头函数和普通函数的区别"><a href="#3、箭头函数和普通函数的区别" class="headerlink" title="3、箭头函数和普通函数的区别"></a>3、箭头函数和普通函数的区别</h5><p>​    1、当函数只有return语句的时候使用箭头函数比较方便，但当返回值为对象时需要在对象外加上（），否则对象的{}会产生歧义；</p>
<p>​    2、箭头函数不能作为构造函数通过new实例化；</p>
<p>​    3、箭头函数没有prototype原型属性</p>
<p>​    4、箭头函数不能使用arguments可以使用…rest</p>
<p>​    5、箭头函数.call()不会改变this的指向，但也能成功调用箭头函数</p>
<p>​    6、普通函数中的this指向将函数作为方法调用的对象，箭头函数的this指向上层普通函数的所属对象，没有上层的时候指向window</p>
<h5 id="4、ES6的模板字符串有哪些新特性"><a href="#4、ES6的模板字符串有哪些新特性" class="headerlink" title="4、ES6的模板字符串有哪些新特性"></a>4、ES6的模板字符串有哪些新特性</h5><p>​    1、字符串中可以识别空格、换行、单引、双引</p>
<p>​    2、可以使用${}形式输出变量以及使用函数、运算符</p>
<h5 id="5、介绍下-Set、Map的区别"><a href="#5、介绍下-Set、Map的区别" class="headerlink" title="5、介绍下 Set、Map的区别"></a>5、介绍下 Set、Map的区别</h5><p>​    1、Set是一种叫做集合的数据结构，Map是一种叫做字典的数据结构；</p>
<p>​    2、Set本身是一种构造函数，用来生成Set数据结构；Map是一组键值对的结构，具有极快的查找速度</p>
<p>​    3、Set成员唯一、无序且不重复；</p>
<p>​    4、Set没有只有键值没有键名；Map既有键值也有键名</p>
<p>​    5、Set的方法有add  delete  clear  has;Map的方法有set  get  delete  clear  has</p>
<h5 id="6、解构赋值是什么"><a href="#6、解构赋值是什么" class="headerlink" title="6、解构赋值是什么"></a>6、解构赋值是什么</h5><p>​    1、按照一定模式从数组和对象中提取值并赋值给变量的过程被称为解构赋值</p>
<p>​    2、分为数组解构和对象解构</p>
<p>​    3、数组解构又分为：单行解构、默认值结构、不定个数结构、逗号占位、多维数组结构集中方式</p>
<p>​    4、对象解构分为：解构指定、多级解构、解构全部和解构时变量改名</p>
<h5 id="7、Promise构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#7、Promise构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="7、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>7、Promise构造函数是同步执行还是异步执行，那么 then 方法呢？</h5><p>​    1、Promise构造函数是同步执行</p>
<p>​    2、then方法是异步执行</p>
<h5 id="8、setTimeout、Promise、Async-Await-的区别"><a href="#8、setTimeout、Promise、Async-Await-的区别" class="headerlink" title="8、setTimeout、Promise、Async/Await 的区别"></a>8、setTimeout、Promise、Async/Await 的区别</h5><p>​    1、setTimeout的回调函数放到宏任务的微任务队列里，等到执行栈清空以后执行</p>
<p>​    2、Promise本身是同步的立即执行函数，但当在执行体中执行resolve或reject的时候是异步操作，会先执行.then里的回调函数将其放到相应的宏任务的微任务队列里，等宏任务里面的同步代码执行完再执行</p>
<p>​    3、Async函数表示函数里可能有异步方法，Async方法执行时遇到await会立即执行表达式，然后把表达式后面的代码放到微任务队列里，让出执行栈让同步代码先执行</p>
<h5 id="9、promise有几种状态，什么时候会进入catch？"><a href="#9、promise有几种状态，什么时候会进入catch？" class="headerlink" title="9、promise有几种状态，什么时候会进入catch？"></a>9、promise有几种状态，什么时候会进入catch？</h5><p>​    1、三种状态：pending(进行中)   resolve(成功)  reject(失败)</p>
<p>​    2、异步操作失败的时候会触发catch返回失败的原因</p>
<h5 id="10、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"><a href="#10、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？" class="headerlink" title="10、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"></a>10、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</h5><p>​    1、常用箭头函数来取代给this赋值在函数内调用的方法</p>
<p>​    2、常用let取代var命令</p>
<p>​    3、常用数组或对象的结构赋值来命名变量（结构更清晰 语义更明确）</p>
<p>​    4、在长字符串多变量组合场合用模板字符串来取代字符串累加</p>
<p>​    5、在大型应用开发中，使用木块化的开发思维，常用import、export方法</p>
<h5 id="11、下面的输出结果是多少"><a href="#11、下面的输出结果是多少" class="headerlink" title="11、下面的输出结果是多少"></a>11、下面的输出结果是多少</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>console.log(1)   console.log(2)  console.log(4)  console.log(3)</p>
<h5 id="12、使用结构赋值，实现两个变量的值的交换"><a href="#12、使用结构赋值，实现两个变量的值的交换" class="headerlink" title="12、使用结构赋值，实现两个变量的值的交换"></a>12、使用结构赋值，实现两个变量的值的交换</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[a,b] = [b,a]</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a,b)</span><br></pre></td></tr></table></figure>



<h5 id="13、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key"><a href="#13、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key" class="headerlink" title="13、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key"></a>13、设计一个对象，键名的类型至少包含一个symbol类型，并且实现遍历所有key</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="title class_">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> goods = &#123;</span><br><span class="line">    [name]:<span class="string">&#x27;Apple 12&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;price&quot;</span>: <span class="number">7999</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(goods)) </span><br></pre></td></tr></table></figure>



<h5 id="14、Promise-中reject-和-catch-处理上有什么区别"><a href="#14、Promise-中reject-和-catch-处理上有什么区别" class="headerlink" title="14、Promise 中reject 和 catch 处理上有什么区别"></a>14、Promise 中reject 和 catch 处理上有什么区别</h5><p>​    1、reject是用来抛出异常的，catch是用来处理异常的</p>
<p>​    2、reject是Promise的方法，而catch是Promise实例的方法</p>
<p>​    3、reject后的东西一定会进入then的第二个回调，如果then中没有写第二个回调，则进入catch</p>
<p>​    4、网络异常出现的错误会直接进入catch而不会进入then的第二个回调</p>
<h5 id="15、使用class-手写一个promise"><a href="#15、使用class-手写一个promise" class="headerlink" title="15、使用class 手写一个promise"></a>15、使用class 手写一个promise</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">	  <span class="title function_">constructor</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">	    <span class="variable language_">this</span>.<span class="property">res</span> = <span class="literal">null</span>;<span class="comment">//存放成功的Value值</span></span><br><span class="line">	    <span class="variable language_">this</span>.<span class="property">err</span> = <span class="literal">null</span>;<span class="comment">//存放失败的Value值</span></span><br><span class="line">	    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;PENDING&#x27;</span>;<span class="comment">//默认是PENGDING状态</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	      <span class="title function_">fn</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">	      	 <span class="comment">//调用该方法就是成功</span></span><br><span class="line">	        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line">	        <span class="variable language_">this</span>.<span class="property">res</span> = res;</span><br><span class="line">	      &#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">	        <span class="comment">//调用该方法就是失败</span></span><br><span class="line">	        <span class="variable language_">this</span>.<span class="property">status</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">	        <span class="variable language_">this</span>.<span class="property">err</span> = err</span><br><span class="line">	      &#125;)</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">	      <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	  <span class="comment">//成功的回调函数</span></span><br><span class="line">	  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">	    <span class="keyword">let</span> self = <span class="variable language_">this</span>;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;resolved&#x27;</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">	      <span class="title function_">onFulfilled</span>(self.<span class="property">res</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;<span class="comment">//失败</span></span><br><span class="line">	      <span class="title function_">onRejected</span>(self.<span class="property">err</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="16、如何使用Set去重"><a href="#16、如何使用Set去重" class="headerlink" title="16、如何使用Set去重"></a>16、如何使用Set去重</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colorArr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>,<span class="string">&#x27;red&#x27;</span>];</span><br><span class="line">colorArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(colorArr)];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colorArr)</span><br></pre></td></tr></table></figure>



<h5 id="17、将下面for循环改成for-of形式"><a href="#17、将下面for循环改成for-of形式" class="headerlink" title="17、将下面for循环改成for of形式"></a>17、将下面for循环改成for of形式</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="18、ES6中…符号的作用"><a href="#18、ES6中…符号的作用" class="headerlink" title="18、ES6中…符号的作用"></a>18、ES6中…符号的作用</h5><p>​    1、实参的个数不确定时，通过…来形参名称接收实参</p>
<p>​    2、当做spread运算符来用</p>
<h5 id="19、forEach、for-in、for-of三者区别"><a href="#19、forEach、for-in、for-of三者区别" class="headerlink" title="19、forEach、for in、for of三者区别"></a>19、forEach、for in、for of三者区别</h5><p>​    1、forEach对数组的每一个元素执行一次提供的函数，不改变原数组，无返回值undefined；不能使用return break等中断循环</p>
<p>​    2、for in 循环遍历的值都是数据结构的键值</p>
<p>​    3、for of 循环遍历的值是键值对中的值，不能直接遍历对象，如有需要遍历对象，需要使用Object.keys()和Object.values()来结合进行遍历</p>
<h5 id="20、javascript中模块化有几种方案，对比说明"><a href="#20、javascript中模块化有几种方案，对比说明" class="headerlink" title="20、javascript中模块化有几种方案，对比说明"></a>20、javascript中模块化有几种方案，对比说明</h5><p>​    1、CommonJS</p>
<p>​    commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<p>暴露模块: module. exports=value或exports.xxx = value<br>引入模块: require(xxx)</p>
<p>​    2、AMD</p>
<p>​    AMD规范采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
<p>使用requirejs实现AMD规范的模块化:用require.config() 指定引用路径等，用define()定义模块，用require()加载模块</p>
<p>​    3、ES6</p>
<p>​    模块功能主要由两个命令构成: export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<h5 id="21、什么是迭代器？工作原理是什么"><a href="#21、什么是迭代器？工作原理是什么" class="headerlink" title="21、什么是迭代器？工作原理是什么"></a>21、什么是迭代器？工作原理是什么</h5><p>​    1、迭代器就是逐个访问数据中各个成员的过程，能通过for of进行遍历的对象都是可迭代对象</p>
<p>​    2、迭代器就是一种机制，是一种接口，为各种不同色数据结构提供统一的访问机制；任何数据结构只要不输Iterator接口，就可以完成遍历操作</p>
<p>​    3、工作原理：</p>
<p>​    （1）创建一个指针对象，指向当前数据结构的起始位置</p>
<p>​    （2）第一次调用对象的next()方法，指针自动指向数据结构的第一个成员</p>
<p>​    （3）接下来不断调用next方法，指针一直往后移动，直到指向最后一个成员</p>
<p>​    （4）每调用next方法都返回一个包含value和done属性的对象</p>
<h5 id="22、介绍生成器的用法"><a href="#22、介绍生成器的用法" class="headerlink" title="22、介绍生成器的用法"></a>22、介绍生成器的用法</h5><p>​    1、生成器是一种异步编程解决方案，语法行为与传统函数完全不同</p>
<p>​    2、首先要创建一个生成器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generator</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello generator!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    然后调用生成器，调用生成器函数只会返回一个迭代器对象，所以还需要执行迭代器的next()方法才能执行生成器中的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = <span class="title function_">generator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行迭代器的next()方法</span></span><br><span class="line">iterator.<span class="title function_">next</span>();</span><br></pre></td></tr></table></figure>



<h5 id="23、什么是回调地狱-如何解决这一问题"><a href="#23、什么是回调地狱-如何解决这一问题" class="headerlink" title="23、什么是回调地狱,如何解决这一问题"></a>23、什么是回调地狱,如何解决这一问题</h5><p>​    1、回调地狱就是回调函数调用回调函数，调用层数越来越多就会产生回调地狱的问题</p>
<p>​    2、使用生成器：</p>
<p>​    Promise：then方法是可以被链式调用的，利用这一特性可以解决异步编程的回调地狱问题</p>
<p>​    Async/await：使用async修饰函数，然后使用await接收异步操作的结果，每个await执行成功后才会执行后面的await</p>
<h5 id="24、简述ES6中Proxy的作用"><a href="#24、简述ES6中Proxy的作用" class="headerlink" title="24、简述ES6中Proxy的作用"></a>24、简述ES6中Proxy的作用</h5><p>​    1、Proxy代理就是在我们访问对象之前添加了一层拦截，可以对目标对象中数据进行过滤和验证</p>
<p>​    2、使用get()进行对象属性的拦截读取</p>
<p>​    3、使用set()进行对象属性的拦截修改</p>
<h5 id="25、call-、apply-、bind-的含义和区别"><a href="#25、call-、apply-、bind-的含义和区别" class="headerlink" title="25、call() 、apply()、bind() 的含义和区别"></a>25、call() 、apply()、bind() 的含义和区别</h5><p>​    1、都是用来重定义this这个对象的</p>
<p>​    2、apply与call的功能时一样的且第一个参数的作用也一样，但call可以传入多个参数，apply只能传入两个参数</p>
<p>​    3、call的参数时直接放进去的，第二个第三个第n个参数之间都是用逗号进行分隔的；apply的所有参数都必须放在一个数组里</p>
<p>​    4、bind和call的参数是一样的，只有返回函数不一样；</p>
<p>​    5、bind方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>node基础1</title>
    <url>/2022/04/06/node%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h2 id="Node-js基础"><a href="#Node-js基础" class="headerlink" title="Node.js基础"></a>Node.js基础</h2><h3 id="一、Node-js概述"><a href="#一、Node-js概述" class="headerlink" title="一、Node.js概述"></a>一、Node.js概述</h3><h4 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h4><ul>
<li><p>Node.js诞生于2009年，由美国人Ryan Dahl（瑞安·达尔）编写</p>
<ul>
<li><p>Ryan Dahl并非科班出身的开发者，在2004年的时候他还在纽约的罗彻斯特大学数学系读博士。 2006年，做出了退学的决定，然后一个人来到智利的Valparaiso小镇。他开始学习网站开发了，走上了码农的道路。  </p>
</li>
<li><p>从那时候开始，Ryan Dahl的生活方式就是接项目，然后去客户的地方工作，在他眼中，拿工资和上班其实就是去那里旅行。Ryan Dahl经过两年的工作后，成为了高性能Web服务器的专家，从接开发应用到变成专门帮客户解决性能问题的专家</p>
</li>
<li><p>2008年Google公司Chrome V8引擎横空出世，JavaScript脚本语言的执行效率得到质的提升</p>
</li>
<li><p>2009年2月Ryan Dahl（瑞安·达尔）开始着手编写Node.js</p>
</li>
<li><p>2010年Ryan Dahl加入Joyent公司，全职负责Node.js项目的开发</p>
<p>​                            </p>
</li>
</ul>
</li>
</ul>
<h4 id="1-2-概念"><a href="#1-2-概念" class="headerlink" title="1.2 概念"></a>1.2 概念</h4><ul>
<li>Node.js是一个基于Chrome V8引擎的JavaScript代码运行环境。</li>
<li>在Node.js之前JavaScript只能通过浏览器运行。Node.js的出现可以让JS脱离浏览器在服务端运行。</li>
<li>从广泛使用 JavaScript 的前端开发者的角度来看，Node.js 让我们可以使用单一语言轻松实现全栈（前端和后端）开发 </li>
</ul>
<h4 id="1-3-特性"><a href="#1-3-特性" class="headerlink" title="1.3  特性"></a>1.3  特性</h4><ul>
<li><p>它是一个JavaScript运行环境</p>
</li>
<li><p>依赖于Chrome V8引擎</p>
</li>
<li><p>轻量，适于实时数据交互应用</p>
</li>
<li><p>单线程</p>
<ul>
<li>所谓”单线程”，就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务，以此类推</li>
<li><strong>JavaScript为什么是单线程？</strong><ul>
<li>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</li>
</ul>
</li>
</ul>
</li>
<li><p>非阻塞I/O</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I/O（英语：Input/Output），即输入/输出，通常指数据在内部存储器和外部存储器或其他周边设备之间的输入和输出。</span><br><span class="line">而在程序执行的过程中会有很多的I/O操作，如读写文件，请求响应，数据库的读写等等</span><br></pre></td></tr></table></figure>

<ul>
<li>非阻塞I/O也就是指程序在执行的过程中，I/O操作不会阻塞程序的执行，也就是在执行I/o操作时，程序的的执行不受影响，继续执行其他的代码（这主要得益于node的事件循环机制），很显然这种非阻塞I/O大大提高了程序的性能。</li>
</ul>
</li>
<li><p>事件驱动</p>
<ul>
<li>Nodejs 会把所有请求和异步操作都放到一个事件队列中，用户的每一个请求就是一个事件。主线程先把普通（同步任务）代码执行完毕，然后会循环事件队列里的函数，如果遇到有IO的操作，nodejs会去线程池里拿出一个线程去执行IO的操作，执行完毕后再把拿到数据的回调函数，放到事件队列的尾部，继续事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 <strong>事件循环</strong> (Event Loop)</li>
</ul>
</li>
</ul>
<h4 id="1-4-Node-js使用场景："><a href="#1-4-Node-js使用场景：" class="headerlink" title="1.4 Node.js使用场景："></a>1.4 Node.js使用场景：</h4><ul>
<li>高并发</li>
<li>即时通讯</li>
<li>推送消息</li>
</ul>
<h4 id="1-5-Node-js-与浏览器运行JavaScript的区别"><a href="#1-5-Node-js-与浏览器运行JavaScript的区别" class="headerlink" title="1.5 Node.js 与浏览器运行JavaScript的区别"></a>1.5 Node.js 与浏览器运行JavaScript的区别</h4><p>浏览器和 Node.js 均可以运行JavaScript，但两者的应用场景各不相同，所以对JS的支持也有所区别，主要体现在以下几个方面：</p>
<ul>
<li><p>浏览器中支持 JavaScript 由三部分组成，ECMAScript，DOM，BOM。 </p>
</li>
<li><p>Node.js 仅支持ECMAScript，不支持DOM、BOM，也就是说Node中没有window、document等对象 </p>
</li>
<li><p>Node.js可以通过其模块提供的不错的 API，例如文件系统访问功能</p>
</li>
<li><p>Node.js 可以通过其模块提供的 API实现很多有用的功能，例如文件系统访问功能、web服务器功能等</p>
</li>
<li><p>Node.js 使用 CommonJS 模块规范，而在浏览器中，使用AMD或ES6 模块标准</p>
</li>
<li><p>在浏览器中全局对象是window，在Node.js中全局对象是global。</p>
</li>
<li><p>Node.js中全局对象下有以下方法，可以在任何地方使用，global可以省略。</p>
<ul>
<li><p>console.log()     在控制台中输出</p>
</li>
<li><p>setTimeout()     设置超时定时器</p>
</li>
<li><p>clearTimeout()  清除超时时定时器</p>
</li>
<li><p>setInterval()      设置间歇定时器</p>
</li>
<li><p>clearInterval()   清除间歇定时器</p>
</li>
</ul>
</li>
</ul>
<h3 id="二、Node-js安装"><a href="#二、Node-js安装" class="headerlink" title="二、Node.js安装"></a>二、Node.js安装</h3><h4 id="2-1-安装与测试"><a href="#2-1-安装与测试" class="headerlink" title="2.1 安装与测试"></a>2.1 安装与测试</h4><ul>
<li><p>官网下载   <a href="https://nodejs.org/en">https://nodejs.org/en</a>      </p>
<ul>
<li>LTS = Long Time Support 长期支持版 稳定版</li>
<li>Current 拥有最新特性 实验版</li>
</ul>
</li>
<li><p>安装</p>
<ul>
<li>next…next…finish即可</li>
</ul>
</li>
<li><p>验证是否安装成功</p>
<ul>
<li><p>在CMD或PowerShell命令行下输入node -v查看node版本信息</p>
<p><img src="/2022/04/06/node%E5%9F%BA%E7%A1%801/image-20210526024237327.png" alt="image-20210526024237327"> </p>
</li>
</ul>
</li>
<li><p>运行文件</p>
<ul>
<li><p>创建hello.js文件，输出Hello World!</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>切换到hello.js文件所在目录下，使用node命令执行js文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-2-安装失败解决办法"><a href="#2-2-安装失败解决办法" class="headerlink" title="2.2 安装失败解决办法"></a>2.2 安装失败解决办法</h4><ul>
<li><p>情况1： 错误代号2502、2503</p>
<ul>
<li>失败原因：系统帐户权限不足。</li>
<li>解决办法：<ul>
<li>以管理员身份运行powershell命令行工具</li>
<li>输入运行安装包命令 msiexec /package  安装包位置</li>
</ul>
</li>
</ul>
</li>
<li><p>情况2：执行命令报错 </p>
<ul>
<li><p>失败原因：Node安装目录写入环境变量失败</p>
</li>
<li><p>解决办法：将Node安装目录添加到PATH环境变量中</p>
<p><img src="/2022/04/06/node%E5%9F%BA%E7%A1%801/image-20210526024808274.png" alt="image-20210526024808274"></p>
</li>
</ul>
</li>
</ul>
<h3 id="三、模块化开发"><a href="#三、模块化开发" class="headerlink" title="三、模块化开发"></a>三、模块化开发</h3><h4 id="3-1-为什么使用模块化开发"><a href="#3-1-为什么使用模块化开发" class="headerlink" title="3.1 为什么使用模块化开发"></a>3.1 为什么使用模块化开发</h4><ul>
<li><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
</li>
<li><p>此外传统JavaScript在使用时还存在两大问题：文件依赖和命名冲突。</p>
</li>
<li><p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。</p>
</li>
<li><p>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！考虑到Javascript模块现在还没有官方规范，这一点就更重要了。</p>
</li>
<li><p>在 ES6 之前，通行的Javascript模块规范共有两种:  CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。</p>
</li>
<li><p>ES6 在语言标准的层面上实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。我们在ES6的课程中再详细讲</p>
</li>
</ul>
<h4 id="3-2-CommonJS规范"><a href="#3-2-CommonJS规范" class="headerlink" title="3.2 CommonJS规范"></a>3.2 CommonJS规范</h4><ul>
<li><p>CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的<code>node</code>上的，前端的<code>webpack</code>也是对CommonJS原生支持的。</p>
</li>
<li><p>根据这个规范，每一个js文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口</span><br></pre></td></tr></table></figure></li>
<li><p>定义模块</p>
<blockquote>
<p>例如： 在test.js中定义一个模块</p>
</blockquote>
<p>方式1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块中的属性和方法</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">x,y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露(导出) 模块中的属性和方法，只有被暴露的属性和方法才可以被外部调用</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">number</span> = number;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">sum</span> = sum;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>这里的<code>test.js</code>就是一个CommonJS规范的模块了。 这里的module就代表了这个模块，module的exports属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的<code>number</code>和<code>sum</code></li>
</ul>
<p>方式2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块中的属性和方法</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span> (<span class="params">x,y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴露(导出) 模块中的属性和方法，只有被暴露的属性和方法才可以被外部调用：</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">number</span>:number,</span><br><span class="line">    <span class="attr">sum</span>: sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式3：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义模块中的属性和方法，同时进行暴露</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">number</span> = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">sum</span> = <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用模块</p>
<blockquote>
<p>例如：在main.js中调用test.js模块</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="keyword">let</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./test.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用模块中的属性和方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">number</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">20</span>)); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li>
<li><p>优点：</p>
<ul>
<li>CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li> 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。</li>
</ul>
</li>
</ul>
<h4 id="3-3-AMD规范"><a href="#3-3-AMD规范" class="headerlink" title="3.3 AMD规范"></a>3.3 AMD规范</h4><ul>
<li><p>AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。</p>
</li>
<li><p>它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>
</li>
<li><p>AMD规范通过<code>define</code>来定义一个模块，然后使用<code>require</code>来加载一个模块。</p>
</li>
<li><p>定义模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="variable language_">module</span>], [depends], callback)</span><br></pre></td></tr></table></figure>

<ul>
<li>module: 模块名称，可以省略。省去之后模块以文件名命名</li>
<li>depends:  所依赖的模块，是一个数组，可以省略。</li>
<li>callback: 模块的内容</li>
</ul>
</li>
<li><p>调用模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="variable language_">module</span>], callback)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例如: </p>
</blockquote>
<p>在test.js中定义模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">x,y</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> x + y;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="attr">number</span>: number,</span><br><span class="line">       <span class="attr">sum</span>: sum   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在main.js中引入模块：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;test&#x27;</span>],<span class="keyword">function</span>(<span class="params">test</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>在html中使用require.js引入主模块main.js</p>
<ul>
<li><p>require.js的诞生，就是为了解决这两个问题：</p>
<ul>
<li>实现js文件的异步加载，避免网页失去响应；</li>
<li>管理模块之间的依赖性，便于代码的编写和维护。</li>
</ul>
</li>
<li><p>使用require.js的第一步，是先去官方网站<a href="http://requirejs.org/docs/download.html">下载</a>最新版本。</p>
</li>
<li><p>一个是把它放在网页底部加载，另一个是写成下面这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;main&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上</li>
<li>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</li>
</ul>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>适合在浏览器环境中异步加载模块。可以并行加载多个模块。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。</li>
</ul>
</li>
</ul>
<h3 id="四、NPM包管理器"><a href="#四、NPM包管理器" class="headerlink" title="四、NPM包管理器"></a>四、NPM包管理器</h3><p>NPM是随同NodeJS一起安装的包管理工具,允许用户从NPM服务器下载别人编写的第三方包到本地使用</p>
<p>NPM是世界上最大的单一语言代码仓库，每星期大约有 30 亿次的下载量，npm 仓库中包含超过 600000 个 软件<em>包（package）</em> </p>
<p>NPM是世界上最大的开源的生态系统。可以通过NPM下载各种包</p>
<p>可以通过<a href="https://www.npmjs.com/">https://www.npmjs.com</a> 查找所需要的包</p>
<blockquote>
<p>例如：通过npm查找下载安装md5加密软件包和日期格式化软件包</p>
</blockquote>
<p><img src="/2022/04/06/node%E5%9F%BA%E7%A1%801/image-20210512055843757.png" alt="image-20210512055843757"></p>
<ul>
<li><p>下载安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install md5 <span class="literal">--save</span></span><br><span class="line">npm install silly<span class="literal">-datetime</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用模块</span></span><br><span class="line">cont md5 = <span class="built_in">require</span>(<span class="string">&#x27;md5&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">md5</span>(<span class="string">&#x27;123456&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用模块</span></span><br><span class="line"><span class="keyword">const</span> sd = <span class="built_in">require</span>(<span class="string">&#x27;silly-datetime&#x27;</span>);</span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sd.<span class="title function_">format</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="4-1-检测npm版本"><a href="#4-1-检测npm版本" class="headerlink" title="4.1  检测npm版本"></a>4.1  检测npm版本</h5><h5 id="4-2-升级"><a href="#4-2-升级" class="headerlink" title="4.2 升级"></a>4.2 升级</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">--global</span> npm</span><br></pre></td></tr></table></figure>

<h5 id="4-3-生成配置文件"><a href="#4-3-生成配置文件" class="headerlink" title="4.3 生成配置文件"></a>4.3 生成配置文件</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跳过向导，快速生成package.json配置文件</span></span><br><span class="line">npm init <span class="literal">-y</span> </span><br></pre></td></tr></table></figure>

<h5 id="4-4-下载"><a href="#4-4-下载" class="headerlink" title="4.4 下载"></a>4.4 下载</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">npm install 包名          // 下载最新版本</span><br><span class="line">npm install 包名<span class="selector-tag">@</span>版本号    // 下载指定版本</span><br><span class="line"><span class="comment"># 简写方式</span></span><br><span class="line">npm i 包名</span><br><span class="line"><span class="comment"># 下载并保存依赖项（package.json文件中dependencies选项）</span></span><br><span class="line">npm install <span class="literal">--save</span> 包名   </span><br><span class="line"><span class="comment"># 简写方式</span></span><br><span class="line">npm i <span class="literal">-S</span> 包名 </span><br></pre></td></tr></table></figure>

<ul>
<li><p>package.json配置文件中的依赖项</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;md5&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;silly-datetime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^0.1.2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>^表示第一位版本号不变，后面两位取最新的</li>
<li>~表示前两位不变，最后一位取最新的</li>
<li>*表示全部取最新的</li>
</ul>
</li>
</ul>
<h5 id="4-5-卸载"><a href="#4-5-卸载" class="headerlink" title="4.5 卸载"></a>4.5 卸载</h5><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卸载，但会保留依赖项</span></span><br><span class="line">npm uninstall 包名 </span><br><span class="line"><span class="comment"># 简写方式</span></span><br><span class="line">npm un 包名</span><br><span class="line"><span class="comment"># 卸载，且不保留依赖项</span></span><br><span class="line">npm uninstall <span class="literal">--save</span> 包名 </span><br><span class="line"><span class="comment"># 简写方式</span></span><br><span class="line">npm un <span class="literal">-S</span> 包名sh</span><br></pre></td></tr></table></figure>

<h5 id="4-6-解决npm-被墙的问题"><a href="#4-6-解决npm-被墙的问题" class="headerlink" title="4.6 解决npm 被墙的问题"></a>4.6 解决npm 被墙的问题</h5><p>方法一：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">--global</span> cnpm</span><br><span class="line"><span class="comment"># 接下来安装包时将npm替换成cnpm，则会通过淘宝的服务器下载</span></span><br><span class="line">cnmp i <span class="literal">-S</span> 包名</span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置为淘宝镜像服务器</span></span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">npm config list</span><br><span class="line"><span class="comment"># 接下来就可以直接使用npm通过淘宝服务器进行下载</span></span><br><span class="line">nmp i <span class="literal">-S</span> 包名</span><br></pre></td></tr></table></figure>



<p>注意：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 如果出现ssl问题，可增加如下配置</span><br><span class="line">npm config <span class="built_in">set</span> strict<span class="literal">-ssl</span> false</span><br><span class="line">// 如果出现proxy问题，可增加如下配置</span><br><span class="line">npm config <span class="built_in">set</span> proxy null</span><br><span class="line">npm config <span class="built_in">set</span> https<span class="literal">-proxy</span> null</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2022/03/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>node模块2</title>
    <url>/2022/04/06/node%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%972/</url>
    <content><![CDATA[<h2 id="构建web服务器"><a href="#构建web服务器" class="headerlink" title="构建web服务器"></a>构建web服务器</h2><h3 id="一、http模块"><a href="#一、http模块" class="headerlink" title="一、http模块"></a>一、http模块</h3><ul>
<li>http模块是node.js的内置系统模块，可以直接通过require调用</li>
<li>http模块主要用来构建web服务器</li>
</ul>
<h4 id="1-1-构建简单web服务"><a href="#1-1-构建简单web服务" class="headerlink" title="1.1 构建简单web服务"></a>1.1 构建简单web服务</h4><ul>
<li><p>实现步骤：</p>
<ul>
<li><p>创建项目文件夹web,在文件夹中创建app.js文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建http服务</span></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// request 表示客户端传过给服务器的的请求信息 </span></span><br><span class="line">  <span class="comment">// response 表示服务器给客户端的响应信息  </span></span><br><span class="line">  <span class="comment">// 设置响应头部</span></span><br><span class="line">  response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">  <span class="comment">// 设置响应内容  </span></span><br><span class="line">  response.<span class="title function_">write</span>(<span class="string">&#x27;Hello World!&#x27;</span>);  </span><br><span class="line">  <span class="comment">// 结束响应</span></span><br><span class="line">  response.<span class="title function_">end</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8081</span>); <span class="comment">// 设置http服务端口</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还可以安装node-snippets插件，快速生成http服务代码</p>
<p><img src="/2022/04/06/node%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%972/image-20210527062754598.png" alt="image-20210527062754598"></p>
</li>
</ul>
</li>
<li><p>运行http服务</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">node http.js</span><br></pre></td></tr></table></figure></li>
<li><p>访问网站</p>
</li>
</ul>
</li>
<li><p>设置汉字编码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建http服务</span></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应头部(设置响应文档类型为html，设置汉字编码为utf-8)</span></span><br><span class="line">  response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html;charset=utf-8&#x27;</span>&#125;);</span><br><span class="line">  <span class="comment">// 设置响应的汉字编码，与响应头部的编码保持一致</span></span><br><span class="line">  response.<span class="title function_">write</span>(<span class="string">&#x27;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt;&#x27;</span>);</span><br><span class="line">  <span class="comment">// 设置响应内容  </span></span><br><span class="line">  response.<span class="title function_">write</span>(<span class="string">&#x27;你好,node.js!&#x27;</span>);  </span><br><span class="line">  <span class="comment">// 结束响应</span></span><br><span class="line">  response.<span class="title function_">end</span>();</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8081</span>); <span class="comment">// 设置http服务端口</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server running at http://127.0.0.1:8081/&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-2-nodemon模块"><a href="#1-2-nodemon模块" class="headerlink" title="1.2 nodemon模块"></a>1.2 nodemon模块</h4><ul>
<li><p>默认情况，每次修改项目中js文件中的代码后都需要手动重新启动此文件才会生效，这样会很麻烦，可以通过安装nodemon模块来解决这一问题  （ 此外supervisor模块也可以提供类似功能 )</p>
</li>
<li><p>安装nodemon</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install nodemon <span class="literal">-g</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过nodemon启动文件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure></li>
<li><p>可能会出现的问题:</p>
<ul>
<li><p>解决方案：</p>
<p>1.以管理员身份打开PowerShell</p>
<p>2.在命令行中输入：set-ExecutionPolicy RemoteSigned </p>
<p>3.选择Y或A即可</p>
</li>
</ul>
</li>
</ul>
<h3 id="二、url模块"><a href="#二、url模块" class="headerlink" title="二、url模块"></a>二、url模块</h3><ul>
<li>url模块是node.js的内置系统模块，可以直接通过require调用</li>
<li>http模块主要用来解析url地址</li>
</ul>
<h4 id="2-1-url-parse"><a href="#2-1-url-parse" class="headerlink" title="2.1 url.parse()"></a>2.1 url.parse()</h4><ul>
<li><p>作用：</p>
<ul>
<li><p>解析url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入http模块</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入url模块</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>  testUrl = <span class="string">&quot;http://www.baidu.com:80/index.html?username=node&amp;age=18&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="title function_">parse</span>(testUrl));</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>输出结果：</p>
</li>
</ul>
</li>
<li><p>获取请求的文件名</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="title function_">parse</span>(testUrl).<span class="property">pathname</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>获取url中所传参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> urlQuery = url.<span class="title function_">parse</span>(testUrl,<span class="literal">true</span>).<span class="property">query</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlQuery)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlQuery.<span class="property">username</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(urlQuery.<span class="property">age</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-url-format"><a href="#2-2-url-format" class="headerlink" title="2.2 url.format()"></a>2.2 url.format()</h4><ul>
<li><p>作用：</p>
<ul>
<li>将url对象格式化为url字符串</li>
</ul>
</li>
<li><p>demo:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> urlObj = &#123;</span><br><span class="line">    <span class="attr">protocol</span>:<span class="string">&#x27;http&#x27;</span>,</span><br><span class="line">    <span class="attr">hostname</span>:<span class="string">&#x27;www.test.com&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>:<span class="number">12345</span>,</span><br><span class="line">    <span class="attr">pathname</span>:<span class="string">&#x27;/index/demo.html&#x27;</span>,</span><br><span class="line">    <span class="attr">query</span>:&#123;</span><br><span class="line">      <span class="attr">username</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>:<span class="number">12</span></span><br><span class="line">    &#125;,  </span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( url.<span class="title function_">format</span>(urlObj) );</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-3-url-resolve"><a href="#2-3-url-resolve" class="headerlink" title="2.3 url.resolve()"></a>2.3 url.resolve()</h4><ul>
<li><p>作用：</p>
<ul>
<li>为URL或 href 插入 或 替换原有的路径</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url.<span class="title function_">resolve</span>(<span class="keyword">from</span>,to)</span><br><span class="line"><span class="comment">//from 源地址</span></span><br><span class="line"><span class="comment">//to 需要添加或替换的标签</span></span><br></pre></td></tr></table></figure></li>
<li><p>demo:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> a = url.<span class="title function_">resolve</span>(<span class="string">&#x27;http://example.com/&#x27;</span>, <span class="string">&#x27;/one&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> b = url.<span class="title function_">resolve</span>(<span class="string">&#x27;http://example.com/one&#x27;</span>, <span class="string">&#x27;/two&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> c = url.<span class="title function_">resolve</span>(<span class="string">&#x27;http://example.com/one/two/three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>) ;</span><br><span class="line"><span class="keyword">let</span> d = url.<span class="title function_">resolve</span>(<span class="string">&#x27;http://example.com/one/two/three&#x27;</span>, <span class="string">&#x27;/four&#x27;</span>) ;</span><br><span class="line"><span class="keyword">let</span> e = url.<span class="title function_">resolve</span>(<span class="string">&#x27;http://example.com/one/two/three&#x27;</span>, <span class="string">&#x27;../four&#x27;</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三、fs模块"><a href="#三、fs模块" class="headerlink" title="三、fs模块"></a>三、fs模块</h3><ul>
<li>fs模块是node.js的内置系统模块，可以直接通过require调用</li>
<li>fs可以对文件和文件夹进行操作,比如读取、写入、创建、删除等</li>
</ul>
<h4 id="3-1-fs-exists"><a href="#3-1-fs-exists" class="headerlink" title="3.1 fs.exists()"></a>3.1 fs.exists()</h4><ul>
<li><p>作用：</p>
<ul>
<li>判断文件是否存在,返回true或false</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步任务</span></span><br><span class="line">fs.<span class="title function_">exists</span>(<span class="string">&quot;./views&quot;</span> , <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步任务</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fs.<span class="title function_">existsSync</span>(<span class="string">&#x27;./views&#x27;</span>) );</span><br></pre></td></tr></table></figure>

<ul>
<li>大多数fs模块的方法都分为同步和异步两种，异步通过回调函数返回结果 ，同步没有回调函数，直接返回结果</li>
</ul>
</li>
</ul>
<h4 id="3-2-fs-stat"><a href="#3-2-fs-stat" class="headerlink" title="3.2 fs.stat()"></a>3.2 fs.stat()</h4><ul>
<li><p>作用：</p>
<ul>
<li> 获取文件状态信息</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&quot;./views&quot;</span>,<span class="function">(<span class="params">err,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取文件状态信息</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="comment">// 判断是否是目录</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isDirectory</span>())</span><br><span class="line">    <span class="comment">// 判断是否是普通文件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">isFile</span>())    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-3-fs-mkdir"><a href="#3-3-fs-mkdir" class="headerlink" title="3.3 fs.mkdir()"></a>3.3 fs.mkdir()</h4><ul>
<li><p>作用</p>
<ul>
<li>创建目录</li>
</ul>
</li>
<li><p>语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&quot;./css&quot;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-4-fs-writeFile"><a href="#3-4-fs-writeFile" class="headerlink" title="3.4 fs.writeFile()"></a>3.4 fs.writeFile()</h4><ul>
<li><p>作用：</p>
<ul>
<li>向文件中写入内容</li>
<li>文件不存在时，会自动创建文件</li>
<li>重复写入会覆盖原内容</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&quot;./views/index.html&quot;</span>,<span class="string">&quot;Hello World!&quot;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;写入成功&quot;</span>); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-5-fs-appendFile"><a href="#3-5-fs-appendFile" class="headerlink" title="3.5 fs.appendFile()"></a>3.5 fs.appendFile()</h4><ul>
<li><p>作用：</p>
<ul>
<li>向文件中追加写入内容</li>
<li>文件不存在时，会自动创建文件</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&quot;./views/index.html&quot;</span> , <span class="string">&quot;第一句话\n&quot;</span> , <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;追加写入成功&quot;</span>); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&quot;./views/index.html&quot;</span>,<span class="string">&quot;第二句话&quot;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;追加写入成功&quot;</span>); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-6-fs-readFille"><a href="#3-6-fs-readFille" class="headerlink" title="3.6 fs.readFille"></a>3.6 fs.readFille</h4><ul>
<li><p>作用：</p>
<ul>
<li>读取文件内容</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;./views/index.html&quot;</span>, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 默认接收到的是Buffer类型，可以通过toString()转换为字符串</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>()); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-7-fs-readdir"><a href="#3-7-fs-readdir" class="headerlink" title="3.7 fs.readdir"></a>3.7 fs.readdir</h4><ul>
<li><p>作用：</p>
<ul>
<li>读取目录</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&quot;./&quot;</span>, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 返回目录下所有文件名称组成的数组</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-8-fs-rename"><a href="#3-8-fs-rename" class="headerlink" title="3.8  fs.rename()"></a>3.8  fs.rename()</h4><ul>
<li><p>作用：</p>
<ul>
<li><p>重命名文件或目录(同一目录下)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./index.html&#x27;</span>,<span class="string">&#x27;./test.html&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;重命名成功&#x27;</span>);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>移动文件或目录(不同目录下)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./test.html&#x27;</span>,<span class="string">&#x27;./views/test.html&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;移动文件成功&#x27;</span>);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="3-9-fs-unlink"><a href="#3-9-fs-unlink" class="headerlink" title="3.9 fs.unlink"></a>3.9 fs.unlink</h4><ul>
<li><p>作用：</p>
<ul>
<li>删除文件</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&quot;./test.html&quot;</span>, <span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;删除文件成功&#x27;</span>);    </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-10-fs-rmdir"><a href="#3-10-fs-rmdir" class="headerlink" title="3.10 fs.rmdir"></a>3.10 fs.rmdir</h4><ul>
<li><p>作用：</p>
<ul>
<li>删除目录(只能删除空目录)</li>
<li>删除非空目录需要先将目录中的文件删除之后，再删除目录</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过递归函数删除非空目录</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delDir</span>(<span class="params">dir</span>)&#123;</span><br><span class="line">    fs.<span class="title function_">readdirSync</span>(dir).<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> filepath = dir + <span class="string">&quot;/&quot;</span> + v;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fs.<span class="title function_">statSync</span>(filepath).<span class="title function_">isDirectory</span>())&#123;</span><br><span class="line">            <span class="title function_">delDir</span>(filepath)             </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            fs.<span class="title function_">unlinkSync</span>(filepath)</span><br><span class="line">        &#125;      </span><br><span class="line">         </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    fs.<span class="title function_">rmdirSync</span>(dir); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">delDir</span>(<span class="string">&quot;./views&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="四、path模块"><a href="#四、path模块" class="headerlink" title="四、path模块"></a>四、path模块</h3><ul>
<li>path模块是node.js的内置系统模块，可以直接通过require调用 </li>
<li>path 模块提供了一些用于处理文件路径的方法</li>
</ul>
<h4 id="4-1-path-extname"><a href="#4-1-path-extname" class="headerlink" title="4.1 path.extname()"></a>4.1 path.extname()</h4><ul>
<li><p>作用：</p>
<ul>
<li>获取path中的文件后缀</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.<span class="title function_">extname</span>(path)</span><br></pre></td></tr></table></figure></li>
<li><p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filepath = <span class="string">&#x27;D:\\code\\node\\index.html&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(filepath));   <span class="comment">//.html          </span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-2-path-basename"><a href="#4-2-path-basename" class="headerlink" title="4.2 path.basename()"></a>4.2 path.basename()</h4><ul>
<li><p>作用：</p>
<ul>
<li>获取path中的文件名</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.<span class="title function_">basename</span>(path[, ext]) </span><br><span class="line"><span class="comment">// ext为扩展名，加了后就不返回扩展名</span></span><br></pre></td></tr></table></figure></li>
<li><p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filepath = <span class="string">&#x27;D:\\code\\node\\index.html&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(filepath));                         <span class="comment">// index.html</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(filepath,<span class="string">&#x27;.html&#x27;</span>));                 <span class="comment">// index</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(filepath,path.<span class="title function_">extname</span>(filepath)));  <span class="comment">// index</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-3-path-dirname-path"><a href="#4-3-path-dirname-path" class="headerlink" title="4.3 path.dirname(path)"></a>4.3 path.dirname(path)</h4><ul>
<li><p>作用：</p>
<ul>
<li>返回path中目录部分</li>
</ul>
</li>
<li><p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">path.<span class="title function_">dirname</span>(path)  </span><br></pre></td></tr></table></figure></li>
<li><p>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filepath = <span class="string">&#x27;D:\\code\\node\\index.html&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(filepath));    <span class="comment">// D:\code\node</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="五、-构建静态web服务"><a href="#五、-构建静态web服务" class="headerlink" title="五、 构建静态web服务"></a>五、 构建静态web服务</h3><ul>
<li><p>目录结构</p>
</li>
<li><p>app.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="comment">// 自定义模块调用</span></span><br><span class="line"><span class="keyword">const</span> mime = <span class="built_in">require</span>(<span class="string">&quot;mime&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>( <span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求的页面路径</span></span><br><span class="line">    <span class="keyword">let</span> pathname = req.<span class="property">url</span> == <span class="string">&#x27;/&#x27;</span> ? <span class="string">&#x27;/index.html&#x27;</span> : req.<span class="property">url</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态文件目录</span></span><br><span class="line">    <span class="keyword">let</span> dir = <span class="string">&quot;static/&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态文件路径</span></span><br><span class="line">    <span class="keyword">let</span> filepath = dir + pathname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pathname !== <span class="string">&#x27;/favicon.ico&#x27;</span>)&#123;</span><br><span class="line">        fs.<span class="title function_">readFile</span>(filepath,<span class="function">(<span class="params">err,data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                res.<span class="title function_">writeHead</span>(<span class="number">404</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/html;charset=&#x27;utf-8&#x27;&quot;</span>&#125;);  </span><br><span class="line">                res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt;&#x27;</span>);</span><br><span class="line">                res.<span class="title function_">write</span>(<span class="string">&quot;404! 页面不存在&quot;</span>)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 获取文件后缀名</span></span><br><span class="line">                <span class="keyword">let</span> ext = path.<span class="title function_">extname</span>(pathname);</span><br><span class="line">                res.<span class="title function_">writeHead</span>(<span class="number">200</span>,&#123;<span class="string">&quot;Content-Type&quot;</span>: mime.<span class="title function_">getmime</span>(ext)+ <span class="string">&quot;;charset=&#x27;utf-8&#x27;&quot;</span>&#125;);</span><br><span class="line">                res.<span class="title function_">write</span>(data);      </span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="title function_">end</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>自定义获取mime类型的包</p>
<ul>
<li><p>创建modules目录，在该目录下创建mime目录，里面主要有以下两个文件</p>
</li>
<li><p>index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">getmime</span> = ext =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;./data/mime.json&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(data.<span class="title function_">toString</span>())[ext];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>.<span class="property">getmime</span> = getmime;</span><br></pre></td></tr></table></figure></li>
<li><p>package.json</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mime&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;getmime&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;index.js&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>初始化npm,通过npm安装自定义包</p>
<ul>
<li><p>修改npm的package.json文件</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;mime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;file:modules/mime&quot;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>执行npm命令进行安装</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm i mime <span class="literal">-S</span>   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>启动http服务</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure></li>
<li><p>通过浏览访问静态页面</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序-面试题</title>
    <url>/2017/05/26/webpack-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h5 id="1-谈谈你对webpack的理解"><a href="#1-谈谈你对webpack的理解" class="headerlink" title="1. 谈谈你对webpack的理解"></a>1. 谈谈你对webpack的理解</h5><p>​    1、webpack是一个现代JavaScript应用程序的静态模块打包器</p>
<p>​    2、当webpack处理应用程序时，会递归的构建一个依赖关系图；其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个包</p>
<p>​    3、在webpack看来，前端的所有资源文件都会作为模块处理</p>
<p>​    4、webpack提供了友好的模块化支持，以及资源的合并、打包、压缩、混淆、处理js兼容问题、性能优化等强大的问题</p>
<h5 id="2-webpack核心概念"><a href="#2-webpack核心概念" class="headerlink" title="2. webpack核心概念"></a>2. webpack核心概念</h5><p>​    1、入口（inter）：指示webpack应该使用哪个模块来作为构建其内部依赖图的开始</p>
<p>​    2、出口（output）：指示webpack打包后的资源输出到哪里去以及如何命名</p>
<p>​    3、loader：让webpack能够处理那些非JavaScript文件，因为webpack默认只能处理JS文件；loader能够将所有类型的文件转换为webpack能够处理的有效模块，然后就可以进行打包</p>
<p>​    4、插件（plugins）：可以用于执行范围更广的任务；包括打包优化和压缩，一直到重新定义环境中的变量等</p>
<p>​    5、模式（Mode）：可设置为development或production来启用相应模式下的webpack内置的优化</p>
<h5 id="3-webpack-dev-server的作用"><a href="#3-webpack-dev-server的作用" class="headerlink" title="3. webpack-dev-server的作用"></a>3. webpack-dev-server的作用</h5><p>​    1、提供了一个基本的web serve，并具有live reloading(实时重新加载)功能；</p>
<p>​    2、帮我们打包生成的bundle.js文件并没有存放到实际的物理磁盘上；而是直接托管到了电脑的内存当中，所以在项目的根目录中是找不到bundle.js这个文件的</p>
<p>​    3、可以认为webpack-dev-serve把打包好的文件以一种虚拟的形式托管到了项目的根目录中</p>
<h5 id="4-webpack如何打包样式资源"><a href="#4-webpack如何打包样式资源" class="headerlink" title="4.webpack如何打包样式资源"></a>4.webpack如何打包样式资源</h5><p>​    1、安装css-loader style-loader、less-loader、sass-loader node-sass</p>
<p>​    2、在rules:[]中进行配置匹配到的文件以及使用到的loader</p>
<h5 id="5-webpack如何打包html资源"><a href="#5-webpack如何打包html资源" class="headerlink" title="5.webpack如何打包html资源"></a>5.webpack如何打包html资源</h5><p>​    1、安装html-webpack-plugin并引入</p>
<p>​    2、在plugins:[]中进行配置</p>
<h5 id="6-webpack如何打包css中图片资源"><a href="#6-webpack如何打包css中图片资源" class="headerlink" title="6.webpack如何打包css中图片资源"></a>6.webpack如何打包css中图片资源</h5><p>​    1、安装url-loader file-loader</p>
<p>​    2、在配置打包样式资源rules:[]中进行配置</p>
<p>​    3、与打包样式资源不同的是使用loader配置使用的loader；使用options来配置输出目录路径等</p>
<h5 id="7-webpack如何打包html中图片资源"><a href="#7-webpack如何打包html中图片资源" class="headerlink" title="7.webpack如何打包html中图片资源"></a>7.webpack如何打包html中图片资源</h5><p>​    1、安装 html-withimg-loader</p>
<p>​    2、在rules:[]中进行配置</p>
<h5 id="8-webpack如何提取CSS为单独文件"><a href="#8-webpack如何提取CSS为单独文件" class="headerlink" title="8.webpack如何提取CSS为单独文件"></a>8.webpack如何提取CSS为单独文件</h5><p>​    1、安装mini-css-extract-plugin并引入</p>
<p>​    2、在rules:[]中进行配置</p>
<p>​    3、在plugins中可以对输出的文件进行重命名</p>
<h5 id="9-webpack对CSS兼容性处理"><a href="#9-webpack对CSS兼容性处理" class="headerlink" title="9.webpack对CSS兼容性处理"></a>9.webpack对CSS兼容性处理</h5><p>​    1、设置需要兼容处理的css样式</p>
<p>​    2、安装postcss postcss-loader  postcss-preset-env</p>
<p>​    3、在package.json中进行对开发环境以及生产环境下浏览器兼容版本的处理</p>
<p>​    4、设置环境变量控制是生产环境还是开发环境；默认是生产环境</p>
<p>​    5、进行postcss-loader的配置</p>
<h5 id="10-webpack如何压缩css"><a href="#10-webpack如何压缩css" class="headerlink" title="10.webpack如何压缩css"></a>10.webpack如何压缩css</h5><p>​    1、安装optimize-css-assets-webpack-plugin并引入</p>
<p>​    2、在plugins中进行配置</p>
<h5 id="11-webpack如何压缩js"><a href="#11-webpack如何压缩js" class="headerlink" title="11.webpack如何压缩js"></a>11.webpack如何压缩js</h5><p>​    将mode改为production，生产环境下回自动压缩js</p>
<h5 id="12-webpack如何压缩html"><a href="#12-webpack如何压缩html" class="headerlink" title="12.webpack如何压缩html"></a>12.webpack如何压缩html</h5><p>​    1、安装html-webpack-plugin并引入</p>
<p>​    2、在plugins中进行配置</p>
<h5 id="13-webpack如何压缩图片"><a href="#13-webpack如何压缩图片" class="headerlink" title="13.webpack如何压缩图片"></a>13.webpack如何压缩图片</h5><p>​    1、安装image-webpack-loader</p>
<p>​    2、在rules:[]中进行配置</p>
<p>​    3、要关闭es6模块采用commonjs</p>
<h5 id="14-HMR（热替换）"><a href="#14-HMR（热替换）" class="headerlink" title="14.HMR（热替换）"></a>14.HMR（热替换）</h5><p>​    1、热替换可以让可以解决当有一个小的修改整个页面都需要刷新的问题，可以只刷新修改的部分</p>
<p>​    2、首先在devServe中进行配置hot:true</p>
<p>​    3、css的热替换需要使用style-loader</p>
<p>​    4、在入口文件中加入index.html</p>
<p>​    5、js的热替换，只要在入口文件中对加载的其他js文件进行设置即可</p>
<h5 id="15-webpack-打包优化思路"><a href="#15-webpack-打包优化思路" class="headerlink" title="15.webpack 打包优化思路"></a>15.webpack 打包优化思路</h5><p>​    1、使用webpack-parallel-uglify-plugin，webpack默认使用UglifyJS去一个个压缩并输出，而webpack-parallel-uglify-plugin插件则会开启多个子进程，将多个文件压缩的工作分配给多个子进程去完成，但每个子进程还是通过UlifyJS去压缩代码</p>
<p>​    2、使用CDN引入资源</p>
<p>​    3、第三方UI组件按需引入</p>
<p>​    4、路由懒加载</p>
<p>​    5、图片懒加载</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>小程序-面试题</title>
    <url>/2017/05/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h5 id="1-微信小程序页面有哪几个文件组成，各有什么作用"><a href="#1-微信小程序页面有哪几个文件组成，各有什么作用" class="headerlink" title="1.微信小程序页面有哪几个文件组成，各有什么作用"></a>1.微信小程序页面有哪几个文件组成，各有什么作用</h5><p>.wxml .wxss .js .json </p>
<p>​    1、.wxml 页面的视图结构，类似于vue组件中的template部分或者html文件中的body部分</p>
<p>​    2、.wxss 页面样式   即css样式</p>
<p>​    3、.js 页面逻辑  进行逻辑处理和异步请求等</p>
<p>​    4、.json 页面配置  可以进行页面注册，设置页面标题，引入子组件或者第三方插件等 </p>
<h5 id="2-微信小程序配置文件有哪几种，各有什么作用"><a href="#2-微信小程序配置文件有哪几种，各有什么作用" class="headerlink" title="2.微信小程序配置文件有哪几种，各有什么作用"></a>2.微信小程序配置文件有哪几种，各有什么作用</h5><p>​    1、全局配置文件app.json：配置小程序的页面路径，设置小程序的状态栏、导航条、标题、窗口背景色等，还可以配置tabBar对象</p>
<p>​    2、工具配置project.config.json：用来记录开发者在开发项目时的个性化配置，包括编辑器的颜色、代码上传时自动压缩等一系列选项</p>
<p>​    3、页面配置文件page.json：在每个页面目录下的json文件，可以独立定义每个页面的一些属性</p>
<h5 id="3-聊聊微信小程序框架架构系统"><a href="#3-聊聊微信小程序框架架构系统" class="headerlink" title="3. 聊聊微信小程序框架架构系统"></a>3. 聊聊微信小程序框架架构系统</h5><p>​    整个小程序框架系统分为两部分：<strong>逻辑层</strong>（App Service）和 <strong>视图层</strong>（View）。小程序提供了自己的视图层描述语言 <code>WXML</code> 和 <code>WXSS</code>，以及基于 <code>JavaScript</code> 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。</p>
<h5 id="4-微信小程序事件如何传值，如何接收传值"><a href="#4-微信小程序事件如何传值，如何接收传值" class="headerlink" title="4.微信小程序事件如何传值，如何接收传值"></a>4.微信小程序事件如何传值，如何接收传值</h5><p>​    通过data-参数名进行传值，通过event.target.dataset.参数名来接收</p>
<h5 id="5-微信小程序如何接收url地址路由传值"><a href="#5-微信小程序如何接收url地址路由传值" class="headerlink" title="5.微信小程序如何接收url地址路由传值"></a>5.微信小程序如何接收url地址路由传值</h5><p>​    在onLoad钩子函数中通过options接收，options要写在钩子函数的参数中</p>
<h5 id="6-微信小程序的-wxss-和-css-有哪些不⼀样的地方"><a href="#6-微信小程序的-wxss-和-css-有哪些不⼀样的地方" class="headerlink" title="6.微信小程序的 wxss 和 css 有哪些不⼀样的地方"></a>6.微信小程序的 wxss 和 css 有哪些不⼀样的地方</h5><p>​    1、wxss不能使用sass和less</p>
<p>​    2、尺寸单位为rpx，可以根据屏幕宽度进行自适应，也可以使用px，在iphone6下 1px=2rpx</p>
<p>​    3、没有body，是page</p>
<h5 id="7-微信小程序的js和原生js有哪些不一样的地方"><a href="#7-微信小程序的js和原生js有哪些不一样的地方" class="headerlink" title="7.微信小程序的js和原生js有哪些不一样的地方"></a>7.微信小程序的js和原生js有哪些不一样的地方</h5><p>​    （1）小程序不是运行在浏览器上的，所有没有BOM和DOM对象；</p>
<p>​    （2）小程序中有一些额外的方法：例如getApp(方法)可以拿到App.js中定义的全局属性和方法；Page方法 用于定义页面对象；</p>
<p>​    （3）小程序的JS是支持CommonJS规范的（导入导出功能）</p>
<h5 id="8-微信小程序组件路由和编程路由的实现"><a href="#8-微信小程序组件路由和编程路由的实现" class="headerlink" title="8.微信小程序组件路由和编程路由的实现"></a>8.微信小程序组件路由和编程路由的实现</h5><p>​    1、组件路由：使用navigator双标签进行实现，通过url属性进行跳转，通过open-type属性设置跳转的页面是否是tab页</p>
<p>​    2、编程路由：首先需要绑定一个点击事件，然后在该事件方法里使用wx.navatorTo或者wx.redirectTo进行非tabBar页的跳转，使用wx.switchTab进行tabBar页面的跳转</p>
<h5 id="9-微信小程序第三方组件库有哪些？你用过哪几种"><a href="#9-微信小程序第三方组件库有哪些？你用过哪几种" class="headerlink" title="9.微信小程序第三方组件库有哪些？你用过哪几种"></a>9.微信小程序第三方组件库有哪些？你用过哪几种</h5><p>​    Lin-ui、WeUI、Vantage、Weapp、IView Weapp几种</p>
<p>​    最常用Lin-ui：是基于微信小程序原生语法实现的组件库。遵循简洁 易用的设计规范；使用npm即可安装，使用的时候将使用到的部分在页面的json配置文件中引入就可以在wxml文件中使用了</p>
<h5 id="10-微信小程序组件间的通信"><a href="#10-微信小程序组件间的通信" class="headerlink" title="10.微信小程序组件间的通信"></a>10.微信小程序组件间的通信</h5><p>​    1、父传子：父组件通过属性向子组件进行传值，子组件通过properties进行接收</p>
<p>​    2、子传父：子组件通过自定义事件中triggerEvent向父组件传值，父组件监听子组件事件的同时通过even.detail进行值的获取</p>
<h5 id="11-微信小程序生命周期"><a href="#11-微信小程序生命周期" class="headerlink" title="11.微信小程序生命周期"></a>11.微信小程序生命周期</h5><p>​    1、onLoad：首次进入页面加载时触发，可以再onLoad的参数中获取打开当前页面路径中的参数</p>
<p>​    2、onShow：加载完成后、后台切到前台或重新进入页面时触发</p>
<p>​    3、onReady：页面首次渲染完成时触发</p>
<p>​    4、onHide：从前台切到后台或进入页面时触发</p>
<p>​    5、onUnload：页面卸载时触发</p>
<p>​    6、onPullDownRefresh：下拉刷新，监听用户下拉动作</p>
<p>​    7、onReachBottom：上拉加载，监听页面上拉触底事件</p>
<p>​    8、onShareAppMessage：用户点击右上角分享</p>
<h5 id="12-微信小程序数据监听器的作用及实现"><a href="#12-微信小程序数据监听器的作用及实现" class="headerlink" title="12.微信小程序数据监听器的作用及实现"></a>12.微信小程序数据监听器的作用及实现</h5><p>​    1、作用：可以监听和响应任何属性和数据字段的变化，变化时会自动调用，只能在自定义组件中使用，在页面组件中无效</p>
<p>​    2、实现：使用attached进行setData设置，使用observes对setData的监听，使用 **可以监听所有的setData</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">observers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;numberA, numberB&#x27;</span>: <span class="keyword">function</span>(<span class="params">numberA, numberB</span>) &#123;</span><br><span class="line">      <span class="comment">// 在 numberA 或者 numberB 被设置时，执行这个函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">sum</span>: numberA + numberB</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="13-聊聊微信小程序中的behavios"><a href="#13-聊聊微信小程序中的behavios" class="headerlink" title="13.聊聊微信小程序中的behavios"></a>13.聊聊微信小程序中的behavios</h5><p>​    1、behaviors是用于组件间的代码共享的特性</p>
<p>​    2、每个behavior都可以包含一组属性、数据、生命周期函数和方法</p>
<p>​    3、组件引用behaviors时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应的时机被调用</p>
<p>​    4、每个组件可以引用多个behaviors，behaviors也可以引用其他behaviors</p>
<h5 id="14-微信小程序中如何显示html标签内容"><a href="#14-微信小程序中如何显示html标签内容" class="headerlink" title="14.微信小程序中如何显示html标签内容"></a>14.微信小程序中如何显示html标签内容</h5><p>一、rich-text</p>
<p>​    是小程序官方提供的一个富文本标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">rich-text</span> <span class="attr">nodes</span>=<span class="string">&quot;&#123;&#123;content&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">rich-text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    content是在js中定义的html内容</p>
<p>二、wxparse</p>
<p>​    1、下载wxparse</p>
<p>​    2、将其中的wxparse目录复制到小程序的项目根目录下</p>
<p>​    3、在app.wxss中引入wxparse.wxss </p>
<p>​    4、在需要加载html内容的页面对应的js文件中引入wxparse.js文件</p>
<p>​    5、通过调用WxParse.wxParse方法来设置html内容</p>
<h5 id="15-微信小程序中如何实现授权登录"><a href="#15-微信小程序中如何实现授权登录" class="headerlink" title="15.微信小程序中如何实现授权登录"></a>15.微信小程序中如何实现授权登录</h5><p>第一步: 定义button属性，获取用户昵称及头像路径</p>
<p>第二步:调用wx.login()方法，获得code并该code作为参数传到后端</p>
<p>第三步:后端将该code 、和appId 、appSecret，作为后端url的参数，调用该微信后端接口，从而得到openid 和 session_key  [提示，安全起见，前端除code之外，其余参数后端直接给参，不做前端参数传递（参数说明：appid//开发者设置中的appid，appSecret//开发者设置中的appSecret，code//小程序调用wx.login返回的code，grant_type//默认参数 authorization_code；）</p>
<p>第四步:将openid 和 session_key 做处理，根据openid去数据库查询，判断是新用户还是老用户登录（老用户直接放行，新用户先入库再放行）</p>
<p>第五步:返回用户的 openid </p>
<p>第六步:小程序端将openid缓存，在其他业务请求时可将其作为参数。</p>
<p>第七步:登录成功进入小程序</p>
<h5 id="16-web-view组件"><a href="#16-web-view组件" class="headerlink" title="16.web-view组件"></a>16.web-view组件</h5><ul>
<li><p>web-view 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面。简单来说，这个组件是一个和当前页面一样大小的容器，容器里显示的是属性src引用的url的内容。类似于html中的iframe框架。不同的是iframe可以自定义大小边框等样式，webview自动铺满整个小程序页面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- wxml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- src地址是需要指向的网站地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-view</span> <span class="attr">src</span>=<span class="string">&quot;https://mp.weixin.qq.com/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">web-view</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>web-view组件限制</p>
<ul>
<li>使用限制：对个人类型和海外类型的小程序暂不支持</li>
<li>指向域名的限制：域名必须为https协议且经过ICP备案<ul>
<li>注：配置域名时，并不是随便一个备案过的https就可以的，需要从配置后台下载校验文件放在域名根目录下，验证通过后才能配置成功</li>
</ul>
</li>
<li>域名修改限制：一个小程序最多可添加20个域名，一年可修改50次</li>
<li>小程序基础库限制：基础裤1.6.4以上版本支持这个组件，低版本需做兼容</li>
</ul>
</li>
<li><p>web-view网页和小程序的联系</p>
<ul>
<li><p>小程序提供了webview网页中使用的JSSDK文件，引用方式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://res.wx.qq.com/open/js/jweixin-1.3.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="property">miniProgram</span>.<span class="title function_">switchTab</span>(&#123;<span class="attr">url</span>: <span class="string">&#x27;/pages/usercenter/usercenter&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h5 id="17-scroll-view组件"><a href="#17-scroll-view组件" class="headerlink" title="17.scroll-view组件"></a>17.scroll-view组件</h5><ul>
<li><p>实现横向滚动和竖向滚动</p>
<ul>
<li><p>竖向滚动</p>
<ul>
<li><p>首先得设置<code>scroll-y</code>属性；</p>
</li>
<li><p>其次，一定要给<code>scroll-view</code>设置一个<code>height</code>高度；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-y</span> <span class="attr">style</span>=<span class="string">&quot;height: 200px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>A<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>B<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>C<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span>D<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    scroll-view view&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100%</span>; <span class="attribute">height</span>: <span class="number">200px</span>; </span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: orange;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>横向滚动</p>
<ul>
<li><p>首先还是要设置滚动方向为<code>scroll-x</code>；</p>
</li>
<li><p>然后要给<code>&lt;scroll-view&gt;&lt;/scroll-view&gt;</code>设置<code>white-space</code>为<code>nowrap</code>不换行；</p>
</li>
<li><p>最后需要将容器中包裹的标签的<code>display</code>属性设置为<code>inline-block</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">scroll-view</span> <span class="attr">scroll-x</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; white-space: nowrap;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">view</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">scroll-view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    scroll-view view&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: inline-block; <span class="attribute">width</span>: <span class="number">200px</span>; <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: skyblue;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    scroll-view view<span class="selector-pseudo">:nth-of-type</span>(<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: orange;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="18-比较bindtap和catchtap"><a href="#18-比较bindtap和catchtap" class="headerlink" title="18.比较bindtap和catchtap"></a>18.比较bindtap和catchtap</h5><ul>
<li>相同点：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分</li>
<li>不同点：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻值冒泡的</li>
<li>非冒泡事件<ul>
<li>如<form>的submit事件，<input>的input事件，<scroll-view>的scroll事件</scroll-view></form></li>
</ul>
</li>
</ul>
<h5 id="19-微信小程序与H5的区别"><a href="#19-微信小程序与H5的区别" class="headerlink" title="19.微信小程序与H5的区别"></a>19.微信小程序与H5的区别</h5><ul>
<li>运行环境不同（小程序在微信运行，h5在浏览器运行）；</li>
<li>开发成本不同（h5需要兼容不同的浏览器）；</li>
<li>获取系统权限不同（系统级权限可以和小程序无缝衔接）；</li>
<li>应用在生产环境的运行流畅度（h5需不断对项目优化来提高用户体验）</li>
</ul>
<h5 id="20-微信小程序如何进行双向绑定"><a href="#20-微信小程序如何进行双向绑定" class="headerlink" title="20.微信小程序如何进行双向绑定"></a>20.微信小程序如何进行双向绑定</h5><ul>
<li><p>方法一：</p>
<ul>
<li><p>通过bindinput事件，然后通过setData设置input的值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;value&#125;&#125;&quot;</span> <span class="attr">bindinput</span>=<span class="string">&quot;setvalue&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">setvalue</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">value</span>: event.<span class="property">detail</span>.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>方法二：</p>
<ul>
<li><p>通过model:value属性来实现,需要2.9.3以上版本支持</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">model:value</span>=<span class="string">&quot;&#123;&#123;value&#125;&#125;&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>vue面试题</title>
    <url>/2017/05/26/%E5%88%9D%E8%AF%86vue/</url>
    <content><![CDATA[<h5 id="1-谈谈你对vue的理解"><a href="#1-谈谈你对vue的理解" class="headerlink" title="1.  谈谈你对vue的理解"></a>1.  谈谈你对vue的理解</h5><p>​    Vue是一套用于构建用户界面的渐进式JavaScript框架，目前Vue的版本最新为去年发布的3.0.0，但由于市场普及度不够，目前还是版本2.0.0使用最为普遍。</p>
<p>​    从整体概念出发来看，Vue作为一套渐进式框架，采用按需分配的模式，就是用多少便引入多少，由开发者自定决定，这提高了项目的运行效率。而且Vue的核心库只关心视图层，比较容易上手，还便于和第三方库或者既有的项目整合。除此之外还有用体积小运行效率高，适合于移动和PC端的开发等优点。然后还借鉴了angular的模板和数据绑定技术以及react的组件化和虚拟DOM技术。</p>
<p>​    从功能方面来看，Vue最核心的功能有两个，一个是响应式数据绑定系统，一个是组件系统。响应式数据系统实现了数据的双向绑定，实现原理是采用数据劫持和订阅-观察模式的结合；组件系统的存在实现了对可重用代码的封装，且扩展了HTML标签的功能。组件之间是相互独立的，无法直接通信，但可以采用一定的办法进行通信。且组件之间可以嵌套，组件也能够被多次复用。</p>
<p>​    Vue还有一系列的扩展插件，比如vue-cli、vue-axios、vue-router、vuex状态管理、vue-lazyload图片懒加载，以及基于Vue的移动端UI组件mint-ui和基于PC端的UI组件库。</p>
<h5 id="2-说说你对-SPA-单页面的理解，它的优缺点分别是什么"><a href="#2-说说你对-SPA-单页面的理解，它的优缺点分别是什么" class="headerlink" title="2. 说说你对 SPA 单页面的理解，它的优缺点分别是什么"></a>2. 说说你对 SPA 单页面的理解，它的优缺点分别是什么</h5><p>​    SPA单页面就是指整个应用只有一个web页面，点击页面中的链接不会刷新页面，只会做页面的局部更新，数据都来自于异步请求，核心技术为前端路由，即Vue-router</p>
<p>​    使用SPA的优点：首先对用户来说，由于单页面应用内容的改变不需要刷新页面没有页面之间的切换，所以页面显示流畅，不会出现白屏的卡顿现象，因此会有良好的用户体验。其次对开发人员来说，由于使用了前后端工作分离模式，后端不再负责模板渲染工作、输出页面工作，实现了后端API通用化，大大减轻了开发人员的工作量。最后对服务器来说，由于单页面应用相对服务器压力小，服务器只用输出数据就可以，不用管展示逻辑和页面合成，所以大大减轻了服务器的压力</p>
<p>​    缺点：首先如果不对路由进行懒加载处理的话，在加载首页的时候，就会将所有组件进行全部加载，导致首屏加载速度过慢的问题。其次SPA不适用于开发大型项目，因为大型项目中会设计大量的DOM操作和复杂的动画效果。最后不利于seo，seo是一个服务器向另一个服务器发起请求，解析请求内容；如果主要解析的内容在还没有加载出的页面中，就会导致内容不利于被搜索引擎搜索到。</p>
<h5 id="3-谈谈你对MVC、MVP、MVVM的理解"><a href="#3-谈谈你对MVC、MVP、MVVM的理解" class="headerlink" title="3.  谈谈你对MVC、MVP、MVVM的理解"></a>3.  谈谈你对MVC、MVP、MVVM的理解</h5><p>​    三种都是开发过程所使用的架构模式，</p>
<p>​    其中MVC是最常见的软件架构之一，该架构分为View视图层、Controller控制层、Model模型层三个部分，工作原理为视图层将用户指令传送到控制层，控制层完成业务逻辑后要求模型层改变状态，模型层将新的数据发送到视图层，使得用户得到反馈。该模式下的所有通信都是单向的，且模型层不依赖于视图层，但是视图层是依赖于模型层的，哦从而导致视图层无法组件化，无法复用。</p>
<p>​    MVP是从MVC模式演变而来的，将Controller改名为Presenter，同时改变了通信方向。与MVC不同的是视图层不直接与模型层进行交互，而是通过控制层来完成交互的，这样可以修改视图而不影响模型，达到解耦的目的，实现了模型层和视图层的真正完全的分离，但模型层到视图层的数据传递过程麻烦，不易维护。</p>
<p>​    MVVM在MVP的模式上继续进行了演变，将Presenter改名为ViewModel，与MVP模式基本一致。唯一的区别是，MVVM采用双向绑定：即View视图层的变动会自动反映在ViewModel上。该模式主要解决了MVP中大量DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验的问题。</p>
<h5 id="4-双向绑定原理分析"><a href="#4-双向绑定原理分析" class="headerlink" title="4. 双向绑定原理分析"></a>4. 双向绑定原理分析</h5><p>​    双向绑定原理是采用数据劫持和订阅-观察者模式的结合而实现的，流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先观察者将遍历Vue对象所有属性，并使用Object.defineProperty把这些属性全部转为getter/setter，从而实现数据劫持；</span><br><span class="line"></span><br><span class="line">​	其次观察者为每个属性分配一个订阅者集合的管理数组dep，然后在编译的时候在该属性的数组dep中添加订阅者Watcher，v-model会添加一个订阅者，&#123;&#123;&#125;&#125;也会，v-bind也会，只要用到该属性的指令理论上都会；</span><br><span class="line"></span><br><span class="line">​	最后为input添加监听事件，修改值时则会触发该属性的set方法，在set方法内通知订阅者数组dep，订阅者数组循环通知各订阅者更新视图；</span><br><span class="line"></span><br><span class="line">​	vue是通过render函数来生成虚拟dom，再映射到页面上</span><br></pre></td></tr></table></figure>

<h5 id="5-虚拟dom的实现原理及优缺点"><a href="#5-虚拟dom的实现原理及优缺点" class="headerlink" title="5.  虚拟dom的实现原理及优缺点"></a>5.  虚拟dom的实现原理及优缺点</h5><p>​    实现原理：<br>​    虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象；状态变更时，记录新树和旧树的差异；最后把差异更新到真正的dom中。</p>
<p>​    优点：<br>​    保证性能下限: 虚拟DOM可以经过diff找出最小差异,然后批量进行patch,这种操作虽然比不上手动优化,但是比起粗暴的DOM操作性能要好很多,因此虚拟DOM可以保证性能下限<br>​    无需手动操作DOM: 虚拟DOM的diff和patch都是在一次更新中自动进行的,我们无需手动操作DOM,极大提高开发效率<br>​    跨平台: 虚拟DOM本质上是JavaScript对象,而DOM与平台强相关,相比之下虚拟DOM可以进行更方便地跨平台操作,例如服务器渲染、移动端开发等等</p>
<p>​    缺点：<br>​    无法进行极致优化: 在一些性能要求极高的应用中虚拟DOM无法进行针对性的极致优化，比如VScode采用直接手动操作DOM的方式进行极端的性能优化</p>
<h5 id="6-常用的vue指令有哪些，各有什么作用"><a href="#6-常用的vue指令有哪些，各有什么作用" class="headerlink" title="6. 常用的vue指令有哪些，各有什么作用"></a>6. 常用的vue指令有哪些，各有什么作用</h5><p>​    在事件绑定上有v-on可简写为@用来绑定事件监听器，实现交互效果，如果事件处理程序比较复杂，也可以指定一个方法 用法为@事件名=‘方法’或者@事件名=‘方法($event)’，方法后不跟括号时，默认第一个参数就是事件对象 ，跟括号时，传递事件对象必须用括号中的参数。</p>
<p>​    在属性绑定上有v-bind，用于绑定html元素属性，可简写为：，绑定class选择器与style行内样式时，都有字符串、对象、数组三种形式。</p>
<p>​    在条件渲染上有v-if v-show，v-if可以根据条件在DOM中渲染或销毁元素或组件，v-show通过改变元素的display属性进行显示和隐藏。v-if适合于条件不经常改变的的场景，因为他的切换开销相对较大，而v-shoe适合于频繁切换条件的场景。</p>
<p>​    在列表渲染中有v-for，用于循环遍历，需要结合in来使用，类似于原生js中for in的用法。</p>
<p>​    在内容绑定上有v-text v-html v-pre v-once，其中v-text用于实现文本插值，与插入表达式同时存在时，该指令生效而表达式不生效，但不建议使用v-text。v-html用于解决插入表达式中含有标签的问题。v-pre和v-once是一个不需要值的指令，前者作用是跳过这个元素和它的子元素的编译过程，是内容原样显示、后者的作用是定义的䛾或组件只能被渲染一次，首次渲染后，不会再随数据的变化而重新渲染。</p>
<p>​    表单元素绑定中的v-model用于实现双向绑定</p>
<p>​    还有自定义指令，可以使用directive注册全局自定义指令，也可以使用directives注册局部自定义指令。</p>
<h5 id="7-常用的事件修饰符有哪些？"><a href="#7-常用的事件修饰符有哪些？" class="headerlink" title="7. 常用的事件修饰符有哪些？"></a>7. 常用的事件修饰符有哪些？</h5><p>​    @click.pevent=’方法’      阻止默认行为</p>
<p>​    @click.stop=’方法’     阻止冒泡</p>
<p>​    @submit.prevent         阻止表单提交，后面不需要跟方法</p>
<p>​    @click.once=”方法”        只触发一次</p>
<p>​    @keyup.enter/tab/delete/esc/space/up/down/left/right</p>
<p>​    @keyup.keyCode.13=’方法’</p>
<p>​    @click.capture=’方法’    采用事件捕获方式</p>
<h5 id="8-v-if和v-show的区别"><a href="#8-v-if和v-show的区别" class="headerlink" title="8. v-if和v-show的区别"></a>8. v-if和v-show的区别</h5><p>​    v-if是通过创建和销毁DOM元素进行内容操作的，而v-show是通过改变元素display属性进行显示和隐藏来操作内容的。</p>
<h5 id="9-v-for中的key属性的作用"><a href="#9-v-for中的key属性的作用" class="headerlink" title="9. v-for中的key属性的作用"></a>9. v-for中的key属性的作用</h5><p>​    使用v-for更新一渲染的元素列表时，默认用就地服用的策略，列表数据修改的时候，会根据key值去判断某个值是否被修改，如果修改则重新渲染这一项，否则复用之前的元素。</p>
<h5 id="10-v-for和v-if-谁优先级高，为什么不建议一起用"><a href="#10-v-for和v-if-谁优先级高，为什么不建议一起用" class="headerlink" title="10. v-for和v-if 谁优先级高，为什么不建议一起用"></a>10. v-for和v-if 谁优先级高，为什么不建议一起用</h5><p>​    v-for优先级高</p>
<p>​    同时使用时，每次渲染都会先循环然后再进行条件判断，带来性能上的浪费</p>
<h5 id="11-如何动态绑定样式Class-与-Style"><a href="#11-如何动态绑定样式Class-与-Style" class="headerlink" title="11. 如何动态绑定样式Class 与 Style"></a>11. 如何动态绑定样式Class 与 Style</h5><p>​    首先使用v-bind指令，然后可以给其传一个对象或者数组，在对象中定义多个字段来动态的切换多个class或行内样式，style可以直接绑定一个样式对象，</p>
<p>​    </p>
<h5 id="12-computed-和-watch-的区别和运用的场景"><a href="#12-computed-和-watch-的区别和运用的场景" class="headerlink" title="12. computed 和 watch 的区别和运用的场景"></a>12. computed 和 watch 的区别和运用的场景</h5><p>​    computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；<br>​    watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>​    运用场景：<br>​    当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p>​    当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h5 id="13-过滤器的作用及用法"><a href="#13-过滤器的作用及用法" class="headerlink" title="13. 过滤器的作用及用法"></a>13. 过滤器的作用及用法</h5><p>​    用于一些常见的文本格式化，可用在双花括号插值和v-bind表达式两个地方。</p>
<p>​    用法上应该被添加在JavaScript边大师的尾部，由管道符指示，分为全局和本地，全局过滤器要在创建Vue实例之前全局定义过滤器，本地过滤器在一个组件的选项中定义。</p>
<h5 id="14-谈谈你对Vue生命周期的理解"><a href="#14-谈谈你对Vue生命周期的理解" class="headerlink" title="14. 谈谈你对Vue生命周期的理解"></a>14. 谈谈你对Vue生命周期的理解</h5><p>​    主要阶段有挂载 更新销毁，分别作用为初始化相关属性、元素或组件的变更操作以及销毁相关属性。</p>
<p>​    具体有beforeCreate  created  beforeMount  mounted  beforeUpdate  updated  beforeDestroy  destroyed；</p>
<p>​    其中beforeUpdate  updated是组件运行阶段的生命周期函数，这两个事件会根据data数据的改变，有选择性的触发0到多次；</p>
<p>​    在beforeCreate阶段中已经初始化了一个Vue空的实例对象，还没有data和methods；</p>
<p>​    在created中data与methods会被初始化好，如果要调用methods中的方法或者操作data中的数据，最早只能在created中；</p>
<p>​    beforeMount执行的时候，模板中已经在内存中编译好了，但是还没有挂载到页面中去；</p>
<p>​    mounted执行完之后，内存中编译好的模板将会被挂载到页面中去，如果要通过某些插件操作页面上的DOM节点，，最早要在mounted中进行，只要执行完了mounted就表示整个Vue实例已经初始化完毕了；</p>
<p>​    当执行beforeDestory的时候 Vue实例已经从运行阶段进入到了销毁阶段，实例中所有的data和methods以及过滤器 指令等还处于可用状态，在执行destroyed的时候，以上所有都已经被销毁掉，组件中的所有data methods 过滤器 指令等都不可再用了。</p>
<h5 id="15-在哪个生命周期内来调用异步请求"><a href="#15-在哪个生命周期内来调用异步请求" class="headerlink" title="15. 在哪个生命周期内来调用异步请求"></a>15. 在哪个生命周期内来调用异步请求</h5><p>​    created和mounted两个时期都可以</p>
<p>​    考虑用户体验方面的话，在created中调用异步请求最佳，用户就越早感知页面的已加载，毕竟越早获取数据，在mounted实例挂载的时候就越及时。</p>
<h5 id="16-谈谈你对vue组件的理解"><a href="#16-谈谈你对vue组件的理解" class="headerlink" title="16. 谈谈你对vue组件的理解"></a>16. 谈谈你对vue组件的理解</h5><p>​    组件的存在实现了对可重用代码的封装，且扩展了HTML标签的功能。组件之间是相互独立的，无法直接通信，但可以采用一定的办法进行通信。且组件之间可以嵌套，组件也能够被多次复用。</p>
<h5 id="17-Vue-js-组件中的-data-为什么是一个函数"><a href="#17-Vue-js-组件中的-data-为什么是一个函数" class="headerlink" title="17. Vue.js 组件中的 data 为什么是一个函数?"></a>17. Vue.js 组件中的 data 为什么是一个函数?</h5><p>​    为了保证组件复用时数据互不干扰，因为函数内返回的是一个未定义的对象，所以每次返回的对象地址都不一样，也就保证了组件之间数据的相互独立。</p>
<p>​    如果data返回的直接是是对象的话，多次使用同一个组件的话返回的地址都相同，那么就会出现data中数据共同变化的情况。</p>
<h5 id="18-vue组件间通信方式哪些？"><a href="#18-vue组件间通信方式哪些？" class="headerlink" title="18. vue组件间通信方式哪些？"></a>18. vue组件间通信方式哪些？</h5><p>​    有三类：分别是父组件向子组件传值、子组件向父组件传值以及兄弟之间的传值。</p>
<h5 id="19-组件插槽的作用、分类及使用场景？"><a href="#19-组件插槽的作用、分类及使用场景？" class="headerlink" title="19. 组件插槽的作用、分类及使用场景？"></a>19. 组件插槽的作用、分类及使用场景？</h5><p>​    1、组件插槽用于父组件向子组件传替模板内容，也算是一种父组件向子组件传值的通信方式。</p>
<p>​    2、有默认插槽、具名插槽和作用域插槽三种。</p>
<p>​    3、默认插槽用于子组件中需要使用两次及两次以上但个别部分不同的情况；当页面中引入多个插槽，就需要用到具名插槽来区分不同的插件；作用域插槽用于父组件对子组件的内容进行加工处理的场景，用的不是很多。</p>
<h5 id="20-为什么在vue中动态绑定src-图片要用require引入"><a href="#20-为什么在vue中动态绑定src-图片要用require引入" class="headerlink" title="20. 为什么在vue中动态绑定src 图片要用require引入"></a>20. 为什么在vue中动态绑定src 图片要用require引入</h5><p>​    动态绑定中路径会被加载器解析为字符串，导致图片找不到</p>
<h5 id="21-怎么理解vue的单项数据流"><a href="#21-怎么理解vue的单项数据流" class="headerlink" title="21. 怎么理解vue的单项数据流"></a>21. 怎么理解vue的单项数据流</h5><p>​    比如父组件向子组件传值，父组件传给子组件的值不能在子组件中被更改</p>
<h5 id="22-父组件可以监听到子组件的生命周期吗？"><a href="#22-父组件可以监听到子组件的生命周期吗？" class="headerlink" title="22. 父组件可以监听到子组件的生命周期吗？"></a>22. 父组件可以监听到子组件的生命周期吗？</h5><p>​    可以 </p>
<p>​    使用on和emit，子组件emit触发事件，父组件on监听相应事件</p>
<p>​    使用hook生命周期钩子函数，在父组件中调用子组件的标签中定义@hook:mounted=‘事件名’，在子组件的mounted周期函数中写入所需操作，然后在父组件中即可监听到子组件mounted中的操作</p>
<h5 id="23-单文件组件有哪几部分组成？各有什么作用"><a href="#23-单文件组件有哪几部分组成？各有什么作用" class="headerlink" title="23. 单文件组件有哪几部分组成？各有什么作用"></a>23. 单文件组件有哪几部分组成？各有什么作用</h5><p>​    template script style三部分，都以双标签的形式存在</p>
<p>​    template部分用于存放页面html元素，</p>
<p>​    script部分存放文件所需的js部分代码，如需要导入的组件，data数据，计算属性，方法声明，以及异步请求的执行也是在该部分中</p>
<p>​    style部分存放页面的样式代码，</p>
<h5 id="24-vue-cli的作用"><a href="#24-vue-cli的作用" class="headerlink" title="24. vue-cli的作用"></a>24. vue-cli的作用</h5><p>​    可以使用命令行快速创建Vue项目，也可以通过Web界面进行项目的构建，还可以封装webpack</p>
<h5 id="25-创建vue项目有哪几种方式？"><a href="#25-创建vue项目有哪几种方式？" class="headerlink" title="25. 创建vue项目有哪几种方式？"></a>25. 创建vue项目有哪几种方式？</h5><p>​    两种，命令行创建和图形化界面创建</p>
<h5 id="26-如何创建和使用一个公共组件？"><a href="#26-如何创建和使用一个公共组件？" class="headerlink" title="26. 如何创建和使用一个公共组件？"></a>26. 如何创建和使用一个公共组件？</h5><p>​    在components目录下创建单文件组件</p>
<p>​    在需要使用的组件中使用import引入然后在template部分引入对应组件标签即可</p>
<h5 id="27-如何创建和使用一个全局方法？"><a href="#27-如何创建和使用一个全局方法？" class="headerlink" title="27. 如何创建和使用一个全局方法？"></a>27. 如何创建和使用一个全局方法？</h5><p>​    在assets目录的js目录下创建js文件将需要的方法定义在该js文件中，然后在main.js文件中引入该文件，</p>
<p>​    多页面使用的话，在需要使用该方法的页面中采用this.js文件名.方法名()的方式来使用。单文件使用就可以直接将其引入在该单页面中，然后采用js文件名.方法名()的方式来使用</p>
<h5 id="28-写过API接口吗？如何保存及更新token令牌"><a href="#28-写过API接口吗？如何保存及更新token令牌" class="headerlink" title="28. 写过API接口吗？如何保存及更新token令牌"></a>28. 写过API接口吗？如何保存及更新token令牌</h5><p>​    保存在localStorage中</p>
<p>​    更新的话，在生成token之后返回数据的时候将过期时间返回，然后在配置axios中将过期时间+存入token的时间存入localStorage作为expire，在token作成真正的同步之前进行token或者过期时间的判断，如果当前时间大于expire，便进行token的刷新</p>
<h5 id="29-什么是RestfulAPI"><a href="#29-什么是RestfulAPI" class="headerlink" title="29. 什么是RestfulAPI"></a>29. 什么是RestfulAPI</h5><p>​    目前最流行的接口设计规范，也是典型的基于HTTP的协议</p>
<p>​    最大的特点是通过URL来描述资源，但要遵守一定的规范，如路径上对资源的描述均使用名词不能使用动词。</p>
<h5 id="30-vue中如何解决ajax跨域请求问题"><a href="#30-vue中如何解决ajax跨域请求问题" class="headerlink" title="30. vue中如何解决ajax跨域请求问题"></a>30. vue中如何解决ajax跨域请求问题</h5><p>​    在开发模式下，使用proxy代理，在proxy中设置跨域，将域名发送给本地的服务器，再由本地的服务器去请求真正的服务器。</p>
<p>​    在生产模式下</p>
<p>​    使用jsonp：1、客户端将不同源的服务器端请求地址写在 script 标签的 src 属性中；2、服务器端响应数据必须是一个函数的调用，真正要发送给客户端的数据需要作为函数调用的参数；3、在客户端全局作用域下定义接收数据的函数（函数名与服务器端传递的函数名相同），即可接收到跨域请求的数据</p>
<p>​    或者cors：通过在服务端响应头中指定允许访问的请求地址的方式解决跨域问题；此外还可express还可以通过安装 cors模块来实现跨域。然后在客户端直接请求接口即可。</p>
<p>​    以及Nginx</p>
<h5 id="31-Vue-cli-工程化都用到了哪些技术，它们的作用分别是什么"><a href="#31-Vue-cli-工程化都用到了哪些技术，它们的作用分别是什么" class="headerlink" title="31.  Vue-cli 工程化都用到了哪些技术，它们的作用分别是什么"></a>31.  Vue-cli 工程化都用到了哪些技术，它们的作用分别是什么</h5><p>​    1、vue.js：是vue-cli工程化的核心，主要特点是双向数据绑定和组件系统</p>
<p>​    2、vue-router：vue官方推荐使用的路由框架</p>
<p>​    3、vuex：Vue.js应用项目开发的状态管理器，主要用于维护vue组件公用的一些变量和方法</p>
<p>​    4、axios：基于Promise设计的用于发起GET或POST等http请求</p>
<p>​    5、webpack：模块加载和vue-cli工程打包器</p>
<h5 id="32-Vue-cli-常⽤的-npm-命令有哪些"><a href="#32-Vue-cli-常⽤的-npm-命令有哪些" class="headerlink" title="32. Vue-cli 常⽤的 npm 命令有哪些"></a>32. Vue-cli 常⽤的 npm 命令有哪些</h5><p>​    1、npm install 用于下载node_modules资源包</p>
<p>​    2、npm run dev 用于启动vue-cli2.0版本下 开发环境下的项目</p>
<p>​    3、npm run serve  用于启动vue-cli3.0版本下开发环境下的项目，</p>
<p>​    4、 npm run build 用于生成生产环境部署资源，即将项目打包，在vue-cli2.0版本下生成的是build文件，3.0下生成的是dist文件</p>
<p>​    5、npm run build–report 用于查看 vue-cli 生产环境部署资源文件大小</p>
<h5 id="33-Vue-中使用了哪些设计模式"><a href="#33-Vue-中使用了哪些设计模式" class="headerlink" title="33. Vue 中使用了哪些设计模式"></a>33. Vue 中使用了哪些设计模式</h5><p>设计模式就是为了解决具体场景下的问题</p>
<p>1、工厂模式-传入参数即可创建实例</p>
<p>​    虚拟DOM根据参数不同返回基础标签的Vnode和组件Vnode</p>
<p>2、单列模式-整个程序有且仅有一个实例</p>
<p>​    vuex和vue-router的插件注册方法install判断 如果系统存在实例就直接返回掉</p>
<p>3、发布-订阅者模式（vue事件机制）</p>
<p>4、观察者模式（响应式数据原理）</p>
<p>5、装饰模式（@装饰器的用法）</p>
<p>​    MVVM，这种设计模式本质上是对MVC的改版。将其中的View的状态和行为抽象化，让我们将视图和业务逻辑分开。</p>
<p>​    View层将指令传递给ViewModel，然后ViewModel进行与Model交互使其进行数据操作，操作成功后ViewModel将结果响应给View</p>
<h5 id="34-Vue路由模式有哪两种？区别是什么"><a href="#34-Vue路由模式有哪两种？区别是什么" class="headerlink" title="34.Vue路由模式有哪两种？区别是什么"></a>34.Vue路由模式有哪两种？区别是什么</h5><p>​    1、hash模式  即地址栏URL中的#符号，</p>
<p>​    2、history模式  利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）</p>
<p>​    区别：</p>
<p>​    hash只能改变#后边的url片段进行修改，而history 就很自由，可以进行切换和修改，使用go back forward进行前进后退，会用pushState 和 replaceState两个方法进行对历史状态的修改</p>
<h5 id="35-什么是懒加载路由"><a href="#35-什么是懒加载路由" class="headerlink" title="35.什么是懒加载路由"></a>35.什么是懒加载路由</h5><p>​    就是延迟加载或者按需加载，使用某个模块的时候才会加载，不使用便不加载</p>
<p>​    像vue这样的单页面应用不进行懒加载处理的话，在打包生成后的文件将会很大，用户进入首页时需要加载所有页面，就会出现首页加载速度过慢的问题</p>
<p>​    import </p>
<p>​    reslove</p>
<h5 id="36-声明式导航与编程式导航的区别"><a href="#36-声明式导航与编程式导航的区别" class="headerlink" title="36.声明式导航与编程式导航的区别"></a>36.声明式导航与编程式导航的区别</h5><p>​    都能进行导航 进行触发路由实现组件之间的切换，但写法不一样</p>
<p>​    1、声明式导航写在template 通过router-link，使用to进行跳转，后面可跟字符串、对象、命名路由等，用的最多还是直接跟路径</p>
<p>​    2、编程式导航写在js函数中 通过this.$router.push()，与声明式导航相同括号内可跟字符串 对象 命名路由等，一般还是直接使用路径进行跳转</p>
<h5 id="37-谈谈路由守卫（导航钩子）"><a href="#37-谈谈路由守卫（导航钩子）" class="headerlink" title="37.谈谈路由守卫（导航钩子）"></a>37.谈谈路由守卫（导航钩子）</h5><p>​    主要用于某些页面需要登录后才能访问，分为全局守卫和局部守卫</p>
<p>​    1、全局守卫挂载在router实例上，使用beforeEach方法进行使用，该方法有三个参数，分别是to from和next to是即将要进入的路由对象 from是当前导航正要离开的路由，next 要结束该方法就要调用next方法，否则不会进入下一个导航</p>
<p>​    2、局部守卫可以写在组件对用的路由配置中，也可以写在组件中，在路由配置中直接定义beforeEnter进行守卫，在组件中使用beforeRouteEnter不能访问this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建</p>
<h5 id="38-使用过mock吗？谈谈mock的作用及如何使用"><a href="#38-使用过mock吗？谈谈mock的作用及如何使用" class="headerlink" title="38.使用过mock吗？谈谈mock的作用及如何使用"></a>38.使用过mock吗？谈谈mock的作用及如何使用</h5><p>​    mock用于在后端API还没开发好的情况下去拦截请求，模拟真实API返回json数据</p>
<p>​    使用的话，首先安装mock插件，然后引入并设为全局属性，在需要使用的页面中使用Mock函数进行拦截设置即可</p>
<h5 id="39-谈谈你对Vuex的理解"><a href="#39-谈谈你对Vuex的理解" class="headerlink" title="39.谈谈你对Vuex的理解"></a>39.谈谈你对Vuex的理解</h5><p>​    1、vuex是一个专为vue.js应用程序开发的状态管理模式</p>
<p>​    2、vuex有五大核心概念，分别是state、getter、mutation、action、module。<br>​    state：存储数据、存储状态，在组件中可通过this.$store.state来访问；存放的数据是响应式的，vue组件从state中读取数据，如果数据发生变化，组件中对应的数据也会更新<br>​    getter：类似于计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算<br>​    actions：进行异步请求，并通过commit调用mutation间接更改vuex中的数据<br>​    mutation：用于更改store中state数据与状态<br>​    modules：将store分割成模块，每个模块都具有五大核心概念，在主模块中调用所有子模块</p>
<p>​    3、vuex的数据传递流程：在组件中通过dispatch调用actions进行异步操作，然后在actions中通过commit调用mutation进行对state中数据的更改，最后state中的数据得到更改然后响应到页面上</p>
<p>​    4、使用vuex进行对数据以及状态进行操作可以使代码变的更加结构化且易于维护</p>
<h5 id="40-Vuex五大核心概念是什么"><a href="#40-Vuex五大核心概念是什么" class="headerlink" title="40.Vuex五大核心概念是什么"></a>40.Vuex五大核心概念是什么</h5><p>​    分别是state、getters、mutations、actions、modules</p>
<p>​    1、state：存储数据，存储状态；在vue组件中用 this.$store.state 来访问；对应vue里面的data，存放数据方式为响应式，vue组件从store中读取数据，如数据发生变化，组件也会对应的更新。</p>
<p>​    2、getters：类似于计算属性，它的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算</p>
<p>​    3、actions：进行异步请求，并通过commit调用mutation间接更改vuex中的数据</p>
<p>​    4、mutations：用于更改store中state数据与状态</p>
<p>​    5、modules：将store分割成模块，每个模块都具有五大核心概念，在主模块中调用所有子模块</p>
<h5 id="41-Vuex与本地存储的区别"><a href="#41-Vuex与本地存储的区别" class="headerlink" title="41.Vuex与本地存储的区别"></a>41.Vuex与本地存储的区别</h5><p>​    1、存储方式不同：vuex存储在内存中，页面的刷新会将更改的数据重置；本地存储中的localStorage是以文件的形式存储在本地，永久保存，不会随着页面的刷新而将数据清除或重置，本地存储中的sessionStorage是会话存储，是临时保存，页面关闭后就会被清除掉</p>
<p>​    2、应用场景不同：vuex用于组件之间的传值，而本地存储用于不同页面之间的传值</p>
<h5 id="42-如何解决Vuex中数据页面刷新重置的问题"><a href="#42-如何解决Vuex中数据页面刷新重置的问题" class="headerlink" title="42.如何解决Vuex中数据页面刷新重置的问题"></a>42.如何解决Vuex中数据页面刷新重置的问题</h5><p>​    在页面刷新之前将数据存到localStorage或sessionStorage中</p>
<p>​    在每次进入到页面的时候进行数据的初始化，每次进行数据的更改的同时也进行对数据库的操作，然后同步vuex中的数据</p>
<h5 id="43-谈谈Vue中axios的使用"><a href="#43-谈谈Vue中axios的使用" class="headerlink" title="43.谈谈Vue中axios的使用"></a>43.谈谈Vue中axios的使用</h5><p>​    用于访问API并展示其数据</p>
<p>​    首先要使用npm安装axios ，然后创建axios.js文件进行对axios的封装，要将其文件在main.js中引入，在封装的文件中需要导入Vue axios以及Vue-axios，并将Vue设为全局属性，然后进行axios的各种设置，比如默认API地址的设置，请求拦截的设置，如果用到token，也是在请求拦截中进行获取以及操作，然后就是响应拦截的设置</p>
<h5 id="44-请说出Vue-cli项目中src目录下主要目录和文件的作用？"><a href="#44-请说出Vue-cli项目中src目录下主要目录和文件的作用？" class="headerlink" title="44.请说出Vue.cli项目中src目录下主要目录和文件的作用？"></a>44.请说出Vue.cli项目中src目录下主要目录和文件的作用？</h5><p>​    main.js：项目的入口文件，在此引入项目所需要的各种第三方插件以及自定义的文件，并进行路由注册，且引入store，并渲染好指定组件将内容挂载到id为app的地方去</p>
<p>​    App.vue：是项目的应用主组件，所有单文件组件都会通过main.js渲染并挂载到该组件中</p>
<p>​    /views：放置各种视图组件</p>
<p>​    /components：放置公共组件</p>
<p>​    /router：放置进行路由配置的路由文件</p>
<p>​    /store：放置vuex文件</p>
<p>​    /assets：放置静态资源文件</p>
<p>​    /plugins：放置插件资源文件，在main.js中被引用</p>
<h5 id="45-Vue中keep-alive的作用"><a href="#45-Vue中keep-alive的作用" class="headerlink" title="45.Vue中keep-alive的作用"></a>45.Vue中keep-alive的作用</h5><p>​    keep-live用来缓存组件，避免多次加载响应的组件，减少性能消耗，比如从页面一链接到页面二再返回到页面一时不用重新再加载页面一的内容，因为页面一的内容已经存在了缓存中</p>
<h5 id="46-active-class是哪个组件的属性"><a href="#46-active-class是哪个组件的属性" class="headerlink" title="46.active-class是哪个组件的属性"></a>46.active-class是哪个组件的属性</h5><p>​    是vue-router模块中声明式导航router-link组件中的属性，用来做选中状态的高亮显示</p>
<p>​    在该属性上设置值然后在样式中直接写样式即可</p>
<h5 id="47-怎么定义Vue-router的动态路由以及如何获取传过来的动态参数"><a href="#47-怎么定义Vue-router的动态路由以及如何获取传过来的动态参数" class="headerlink" title="47.怎么定义Vue-router的动态路由以及如何获取传过来的动态参数"></a>47.怎么定义Vue-router的动态路由以及如何获取传过来的动态参数</h5><p>​    有query和params两种方式</p>
<p>​    1、query：传递的时候在对象中使用query的key作为传递方式或者直接拼在path后，传递后的参数会统一拼在路径后，可以使用$route.query来获取传递的值</p>
<p>​    2、params：配置路由路径的时候在后面拼上需要传递的参数名，传递的时候在path后跟上对应的值，用$route.params来获取传递的参数</p>
<h5 id="48-Vue过渡如何实现"><a href="#48-Vue过渡如何实现" class="headerlink" title="48.Vue过渡如何实现"></a>48.Vue过渡如何实现</h5><p>​    Vue有内置的过渡封装组件，使用的时候将需要过渡的部分用transtion组件标签包裹，默认有六个class的切换，分别是v-enter、v-enter-active、v-enter-to、v-leave、v-leave-active、v-leave-to，分别控制元素进入或离开的开始状态、生效时的状态以及结束状态</p>
<p>​    多元素过渡时需要在每个元素上添加key值</p>
<h5 id="49-Vue动画如何实现"><a href="#49-Vue动画如何实现" class="headerlink" title="49.Vue动画如何实现"></a>49.Vue动画如何实现</h5><p>​    可以使用内置的动画封装组件也可以引入第三方插件</p>
<p>​    1、使用内置的动画封装组件时需要将有动画的部分用transtion标签包括，使用v-enter-active 指定显示的transition    进入，v-leave-active 指定显示的transition 离开</p>
<p>​    2、引入animate.css第三方库，或安装第三方库，在需要使用的地方写入动画的name，使用enter-active-class和leave-active-class设置需要的动画</p>
<h5 id="50-Vue多元素过渡如何实现"><a href="#50-Vue多元素过渡如何实现" class="headerlink" title="50.Vue多元素过渡如何实现"></a>50.Vue多元素过渡如何实现</h5><p>​    在transtion-group组件标签包括在内的每个元素设置不同的key值用于区分不同的元素</p>
<h5 id="51-Vue第三方动画如何实现"><a href="#51-Vue第三方动画如何实现" class="headerlink" title="51.Vue第三方动画如何实现"></a>51.Vue第三方动画如何实现</h5><p>​    引入animate.css第三方库，或安装第三方库，在需要使用的地方写入动画的name，使用enter-active-class和leave-active-class设置需要的动画</p>
<h5 id="52-nextTick的作用、实现原理以及使用场景"><a href="#52-nextTick的作用、实现原理以及使用场景" class="headerlink" title="52.nextTick的作用、实现原理以及使用场景"></a>52.nextTick的作用、实现原理以及使用场景</h5><p>​    1、作用：在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的DOM；相当于一个延迟的作用</p>
<p>​    2、实现原理：nextTick方法主要是使用了宏任务和微任务，定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空队列。</p>
<p>​    3、使用场景：用在一切DOM还没更新完成的场景中</p>
<h5 id="53-描述Vue中webpack常用配置"><a href="#53-描述Vue中webpack常用配置" class="headerlink" title="53.描述Vue中webpack常用配置"></a>53.描述Vue中webpack常用配置</h5><p>​    1、在package.json中设置webpack的mode</p>
<p>​    2、在vue.config.js判断环境是生产环境还是开发环境，进行相应的配置，在生产环境下可以关闭语法书写规范的检查，如果不需要生产环境的source map，可以将其设置为false以加速生产环境的构建；在开发环境下也可以关闭语法书写规范的检查，并且设置热启动，如端口号、用于跨域的代理等</p>
<p>​    3、在axios.js中配置默认的API地址</p>
<h5 id="54-Vue项目优化方法有哪些"><a href="#54-Vue项目优化方法有哪些" class="headerlink" title="54.Vue项目优化方法有哪些"></a>54.Vue项目优化方法有哪些</h5><p>​    首先生成打包报告，查看哪些占用空间比较大的插件。</p>
<p>​    1、第三方库启用CDN，默认情况下通过import语法导入第三方依赖包，最后会被打包合并到统一文件中，从而导致打包后单个文件体积过大的问题；</p>
<p>​    启用CDN的，首先在配置文件中将第三方依赖包声明在externals中，然后在index.html中通过CDN在线网址引入各种插件，这样第三方包就不会被打包合并，不过有个缺点就是不太稳定</p>
<p>​    2、element-ui/mint-ui组件按需加载</p>
<p>​    3、路由懒加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">List</span> = (<span class="params"></span>) =&gt; <span class="title function_">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: <span class="title class_">List</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">方式二：</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里是你的模块 不用import去引入了</span></span><br><span class="line">        <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4、图片懒加载</p>
<p>​    安装lazy-load，进行全局注册，v-lazy=“”使用</p>
<h5 id="55-Vue项目上线部署方式有哪些"><a href="#55-Vue项目上线部署方式有哪些" class="headerlink" title="55.Vue项目上线部署方式有哪些"></a>55.Vue项目上线部署方式有哪些</h5><p>express方式：</p>
<p>​    1、创建web服务器</p>
<p>​    新建项目目录并初始化npm配置，然后安装express框架，将打包生成的dist目录拷贝到项目目录下，创建app.js文件，利用express创建web服务（配置静态资源托管中间件并配置端口）</p>
<p>​    2、开启文件的gzip网络传输压缩（使用gizp可以减少文件网络传输时的体积，加快传输速度，让网页更快的显示）</p>
<p>​    3、配置HTTPS服务（使用HTTPS服务更加安全可靠）</p>
<h5 id="56-用过哪些Vue相关的UI框架？使用过它们的哪些功能"><a href="#56-用过哪些Vue相关的UI框架？使用过它们的哪些功能" class="headerlink" title="56.用过哪些Vue相关的UI框架？使用过它们的哪些功能"></a>56.用过哪些Vue相关的UI框架？使用过它们的哪些功能</h5><p>​    element-ui和mint-ui，都是饿了么团队开发的ui框架</p>
<p>​    1、PC端使用element-ui，比较经常用它的导航菜单、标签页、日历、alert警告框，message消息提示，messageBox弹框等功能</p>
<p>​    2、mint-ui是一个支持移动端的的ui框架，在写电商网站加入购物车的功能有用到popup这个功能，还有首页的无限加载有用到loadmore以及indicator，各种提示信息会用到toast，除此之外还常用到swiper进行图片的轮播展示</p>
<h5 id="57-vue防抖和节流是什么"><a href="#57-vue防抖和节流是什么" class="headerlink" title="57.vue防抖和节流是什么"></a>57.vue防抖和节流是什么</h5><p>解决事件高频触发，都保证了单位时间内只会触发一次事件</p>
<p>​    1、防抖：触发高频事件n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间；因为防抖的特性，一直执行最后一次的触发，所以可以用于鼠标移动确定最后一次移动的时候的坐标位置。</p>
<p>​    2、节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率；因为节流是监听到第一次触发事件后就执行，所以可以用来防止按钮多次点击执行多次，且按照第一次点击的事件为准</p>
<h5 id="58-Vue中-route-和-router-的区别"><a href="#58-Vue中-route-和-router-的区别" class="headerlink" title="58.Vue中$route 和 $router 的区别"></a>58.Vue中$route 和 $router 的区别</h5><p>​    1、route是指当前页面的路由信息，包含了当前URL解析得到的信息，比如路径、参数、query对象等</p>
<p>​    2、router是全局路由的实例，是router构造方法的实例，包含了所有路由信息，主要用于页面的跳转</p>
<h5 id="59-Vue中事件绑定的原理"><a href="#59-Vue中事件绑定的原理" class="headerlink" title="59.Vue中事件绑定的原理"></a>59.Vue中事件绑定的原理</h5><p>​    Vue中事件绑定有两种，一种是原生的事件绑定，另一种是组件的事件绑定$on</p>
<p>​    1、原生的事件绑定在普通元素上是通过addEventListener进行绑定;</p>
<p>​    2、在组件上是通过@click.native进行绑定,组件的事件绑定的@click是vue中自定义的 <code>$on</code>方法来实现的，必须有<code>$emit</code>才可以触发； </p>
<h5 id="60-Vue中相同逻辑如何抽离"><a href="#60-Vue中相同逻辑如何抽离" class="headerlink" title="60.Vue中相同逻辑如何抽离"></a>60.Vue中相同逻辑如何抽离</h5><p>​    使用Vue.mixin方法（混入），其提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。说白了就是给每个生命周期，函数等等中间加入一些公共逻辑。</p>
<p>​    小程序中的behaviors，类似mixin、traits</p>
<h5 id="61-什么是服务器端渲染-SSR"><a href="#61-什么是服务器端渲染-SSR" class="headerlink" title="61.什么是服务器端渲染 (SSR)"></a>61.什么是服务器端渲染 (SSR)</h5><p>​    1、是服务端生成静态的HTML字符串，浏览器将静态标记“混合“为客户端可交互的应用程序</p>
<p>​    2、服务器渲染的Vue.js应用程序也可以被认为是“同构”或“通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行</p>
<p>​    3、与传统的SPA相比，服务端渲染的优势主要在于：更好的seo和加快首屏加载速度</p>
<p>​    4、代价：开发条件首先monted，构建部署要求多，服务器负载会变大</p>
<p>​    5、实现：vue-server-render  express</p>
<h5 id="62-Vue3和Vue2相比有哪些变化"><a href="#62-Vue3和Vue2相比有哪些变化" class="headerlink" title="62.Vue3和Vue2相比有哪些变化"></a>62.Vue3和Vue2相比有哪些变化</h5><p>​    1、性能的提升：打包大小减少41%，除此渲染快55%，更新渲染快133%，内存减少54%</p>
<p>​    2、源码的升级：使用Proxy代替defineProperty实现响应式，重写虚拟DOM的实现，webpack中使用了Tree-Shaking技术</p>
<p>​    3、更好的支持TypeScript</p>
<p>​    4、有新的特性：（1）组合式API（2）组件的多根节点支持                        （3）新的内置组件 Fragment Teleport Suspense （4）生命周期钩子函数的变化</p>
<p>​    5、废弃了一些功能：移除了keyCode支持作为v-on的修饰符；废弃了过滤器</p>
<h5 id="63-创建Vue3工程的方式有哪些"><a href="#63-创建Vue3工程的方式有哪些" class="headerlink" title="63.创建Vue3工程的方式有哪些"></a>63.创建Vue3工程的方式有哪些</h5><p>​    1、使用vue-cli创建：需要vue-cli版本在4.5.0以上</p>
<p>​    2、使用vite创建：vite是新一代前端构建工具，有以下优势：在开发环境在无需打包操作，可快速的冷启动；轻量快速的热重载；真正的按需编译，不会再等待整个应用编译完成</p>
<h5 id="64-谈谈你对Composition-API（组合式API-的理解"><a href="#64-谈谈你对Composition-API（组合式API-的理解" class="headerlink" title="64.谈谈你对Composition API（组合式API)的理解"></a>64.谈谈你对Composition API（组合式API)的理解</h5><p>​    1、是一组低入侵式的，函数式的API，是的我们能够更灵活的组合组件的逻辑</p>
<p>​    2、有一定的优点和缺点：组合式API不再像以前那样对代码进行了强制性的分割，代码组织非常灵活。但对新手来说，在逻辑越来越复杂的情况下，setup的代码量会越来越多，同时setup内的return也越来越多，将会落入到面条代码之中</p>
<h5 id="65-Vue3和Vue2的响应式系统有什么不同"><a href="#65-Vue3和Vue2的响应式系统有什么不同" class="headerlink" title="65.Vue3和Vue2的响应式系统有什么不同"></a>65.Vue3和Vue2的响应式系统有什么不同</h5><p>​    1、Vue2响应式的核心是通过defineProperty方法进行对已有属性值读取和修改的劫持而实现的</p>
<p>​    2、Vue3响应式是通过Proxy代理拦截对data任意属性的任意操作进行实现的</p>
<h5 id="66-ref和reactive的作用"><a href="#66-ref和reactive的作用" class="headerlink" title="66.ref和reactive的作用"></a>66.ref和reactive的作用</h5><p>​    1、ref函数：定义一个基本数据类型的响应式数据，依靠Object.defineProperty()的get与set完成的；；.value</p>
<p>​    2、reactive函数：定义一个对象类型的响应式数据，基于Proxy实现数据劫持，通过代理对象操作源对象内部数据进行操作</p>
<h5 id="67-toRef与toRefs的作用"><a href="#67-toRef与toRefs的作用" class="headerlink" title="67.toRef与toRefs的作用"></a>67.toRef与toRefs的作用</h5><p>​    1、toRef：将响应式对象的某个属性单独提供给外部使用，使用时接收两个参数，第一个参数是对象的名称，第二个参数是要提供给外部的对象的属性</p>
<p>​    2、toRefs：将响应式对象所有属性都设置为可供外部单独使用，使用时接受一个对象作为参数即可，它会遍历对象身上的所有属性，然后挨个调用toRef执行,加上…扩展运算符</p>
<h5 id="68-Vue3中的生命周期函数有哪些变化"><a href="#68-Vue3中的生命周期函数有哪些变化" class="headerlink" title="68.Vue3中的生命周期函数有哪些变化"></a>68.Vue3中的生命周期函数有哪些变化</h5><p>​    Vue3中用setup代替了Vue2的beforeCreate和created两个周期函数，Vue3中用onBeforeMount代替了Vue2的beforeMount周期函数；除此之外还有以下改变情况，使用的时候</p>
<p><code>mounted ----&gt;onMounted</code></p>
<p><code>beforeUpdate ----&gt;onBeforeUpdate</code></p>
<p><code>updated ----&gt;onUpdated</code></p>
<p><code>beforeDestory ----&gt;onBeforeUnmount</code></p>
<p><code>destoryed ----&gt;onUnmounted</code></p>
<h5 id="69-组件式API中setup函数有哪些参数，各有什么作用"><a href="#69-组件式API中setup函数有哪些参数，各有什么作用" class="headerlink" title="69.组件式API中setup函数有哪些参数，各有什么作用"></a>69.组件式API中setup函数有哪些参数，各有什么作用</h5><p>​    1、props参数：包含组件外部传递过来且组件内部声明接收了的属性；比如父组件通过属性给子组件传值，子组件通过props参数接收</p>
<p>​    2、context参数：是上下文对象，含有三部分：attrs包含组件外部传递过来但没有在props配置中声明的属性,相当于<code>this.$attrs</code>；slots包含收到的插槽内容相当于<code>this.$slots</code>;emit包含分发自定义事件的函数，相当于<code>this.$emit</code></p>
<h5 id="70-provide-与-inject的作用"><a href="#70-provide-与-inject的作用" class="headerlink" title="70.provide 与 inject的作用"></a>70.provide 与 inject的作用</h5><p>​    1、实现组件与后代组件间的通信</p>
<p>​    2、父组件使用provide选项来提供数据，后代组件使用inject选项来使用这些数据</p>
<p>（使用特别多）</p>
<h5 id="71-什么是hook"><a href="#71-什么是hook" class="headerlink" title="71.什么是hook"></a>71.什么是hook</h5><p>​    1、本质是一个函数，把setup函数中使用的组合式API进行了封装，类似于Vue2中的mixin</p>
<p>​    2、Vue3中使用自定义hook可以将复用代码进行封装，让setup中的逻辑更清楚易懂</p>
<p>​    3、使用：在src目录下新建hook目录，下面创建自定义文件，创建完成后在需要使用的组件中先使用import进行导入，然后即可使用</p>
<h5 id="72-Vue3中Fragment新组件的作用"><a href="#72-Vue3中Fragment新组件的作用" class="headerlink" title="72.Vue3中Fragment新组件的作用"></a>72.Vue3中Fragment新组件的作用</h5><p>​    1、作为虚拟根标签的一种存在，可以让组件没有根标签</p>
<p>​    2、可以减少标签层级，减小内存占用</p>
<h5 id="73-Vue3中Teleport新组件的作用"><a href="#73-Vue3中Teleport新组件的作用" class="headerlink" title="73.Vue3中Teleport新组件的作用"></a>73.Vue3中Teleport新组件的作用</h5><p>​    1、是一种能够将我们组件html结构移动到指定位置的技术</p>
<p>​    2、比如弹层就可以使用该技术，弹层不需要的使用将其移动到body下</p>
<h5 id="74-Vue3中Suspense新组件的作用"><a href="#74-Vue3中Suspense新组件的作用" class="headerlink" title="74.Vue3中Suspense新组件的作用"></a>74.Vue3中Suspense新组件的作用</h5><p>​    1、等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
<p>​    2、使用时要先引入defineAsyncComponent和子组件，然后使用suspense包裹组件并配置好default和fallback即可</p>
<h5 id="75-Composition-API和option-API优劣对比"><a href="#75-Composition-API和option-API优劣对比" class="headerlink" title="75.Composition API和option API优劣对比"></a>75.Composition API和option API优劣对比</h5><p>​    1、Composition API不像option API那样将代码的各部分进行分割，而是将所有代码都写进了setup中，所以代码组织变的非常灵活</p>
<p>​    2、在进行代码修改的时候，Composition API更加的有条理更加的方便</p>
<p>​    3、Componsition API中没有对this的使用，减少了this指向不明的情况</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
</search>
